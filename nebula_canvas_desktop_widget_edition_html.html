<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Igo — Desktop Widget Edition</title>
<style>
  :root{
    --bg:#0b0f15; --panel:#111722; --elev:#131b2a; --grid:#0f1520;
    --text:#e9eef5; --muted:#9aa3ad; --border:#233041; --accent:#7dd3fc; --accent2:#a78bfa; --ok:#34d399; --danger:#ef4444;
    --shadow:0 14px 38px rgba(0,0,0,.38);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;padding:0;background:transparent;color:var(--text);font:14px/1.45 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;height:100vh;overflow:hidden}
  a{color:inherit}

  /* Widget Panel */
  .widget{position:absolute;top:0;left:0;right:0;bottom:0;border-radius:20px;overflow:hidden;border:1px solid var(--border);
          background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));backdrop-filter:blur(18px) saturate(140%);
          box-shadow:var(--shadow);transform-origin:center;transform:scale(.0) translateY(8px);opacity:0;transition:transform .28s,opacity .2s;
          display:flex;flex-direction:column}
  .widget.open{transform:scale(1);opacity:1}
  .widget.s{width:640px;height:520px}
  .widget.m{width:980px;height:640px}
  .widget.l{width:1200px;height:760px}
  .widget.left{left:24px;right:auto;transform-origin:bottom left}



  /* Header */
  .top{display:flex;align-items:center;gap:10px;padding:10px 12px;background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,0));border-bottom:1px solid var(--border)}
  .drag{flex:1;display:flex;align-items:center;gap:10px;user-select:none;-webkit-app-region:drag}
  .logo{display:flex;align-items:center;gap:10px;font-weight:800}
  .logo b{width:28px;height:28px;border-radius:50%;display:grid;place-items:center;background:transparent;color:rgba(255,255,255,0.95);font-size:16px;font-weight:900;text-shadow:0 2px 8px rgba(139,92,246,0.6),0 1px 4px rgba(0,0,0,0.3);filter:drop-shadow(0 0 8px rgba(125,211,252,0.4));transition:all 0.3s ease}
  .logo:hover b{color:rgba(125,211,252,1);text-shadow:0 3px 12px rgba(125,211,252,0.8),0 2px 6px rgba(139,92,246,0.6),0 1px 4px rgba(0,0,0,0.4);filter:drop-shadow(0 0 12px rgba(125,211,252,0.8));transform:rotate(90deg) scale(1.1)}
  .search{flex:1;display:flex;align-items:center;gap:8px;background:var(--elev);border:1px solid var(--border);border-radius:12px;padding:8px 10px;-webkit-app-region:no-drag}
  .search input{flex:1;border:0;outline:0;background:transparent;color:var(--text);-webkit-app-region:no-drag}
  .toolbar{display:flex;gap:6px;-webkit-app-region:no-drag}
  .btn{border:1px solid var(--border);background:var(--elev);color:var(--text);border-radius:10px;padding:8px 10px;cursor:pointer;-webkit-app-region:no-drag}
  .btn:hover{background:rgba(255,255,255,.08)}

  /* Body */
  .body{display:flex; gap:2px !important; padding:8px; flex:1; min-height:0; transition: all 0.3s ease;}
  .body.sidebar-hidden .left-sidebar{display: none !important;}

  /* Board area */
  .boardwrap{position:relative; border:1px solid var(--border); border-radius:14px; overflow:hidden; background:var(--panel); margin:0; padding:0; flex:1;}
  .boardbg{position:absolute; inset:0; pointer-events:none; background:
      linear-gradient(0deg, transparent 24px, var(--grid) 25px),
      linear-gradient(90deg, transparent 24px, var(--grid) 25px),
      radial-gradient(40% 60% at 10% 10%, rgba(99,102,241,.12), transparent 60%),
      radial-gradient(40% 60% at 90% 80%, rgba(34,211,238,.10), transparent 60%);
    background-size: 25px 25px, 25px 25px, 100% 100%, 100% 100%;}
  #board{position:absolute; inset:0; transform-origin:0 0; transition:none; will-change:transform; isolation: isolate;}
  
  /* Bağlantı çizgileri */
  .connection-line {
    position: absolute;
    height: 1px;
    background: rgba(125,211,252,0.4);
    transform-origin: left center;
    pointer-events: none;
    z-index: 0;
    transition: none;
  }
  
  .connection-line::after {
    content: '';
    position: absolute;
    right: -8px;
    top: -3px;
    width: 0;
    height: 0;
    border-left: 8px solid rgba(125,211,252,0.6);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
  }
  
  /* Bağlantı türleri */
  .connection-line.bidirectional {
    background: linear-gradient(90deg, rgba(52,211,153,0.6), rgba(125,211,252,0.6));
  }
  
  .connection-line.bidirectional::before {
    content: '';
    position: absolute;
    left: -8px;
    top: -3px;
    width: 0;
    height: 0;
    border-right: 8px solid rgba(52,211,153,0.6);
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
  }
  
  .connection-line.weak {
    opacity: 0.3;
    height: 1px;
  }
  
  .connection-line.strong {
    height: 3px;
    box-shadow: 0 0 8px rgba(125,211,252,0.4);
  }
  
  /* Bağlantı etiketleri */
  .connection-label {
    position: absolute;
    background: var(--elev);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 2px 6px;
    font-size: 11px;
    color: var(--text);
    pointer-events: none;
    z-index: 0;
    white-space: nowrap;
  }
  
  /* Hub notlar için özel stil */
  .note.hub {
    border-color: var(--ok);
    box-shadow: 0 0 20px rgba(52,211,153,0.3);
  }
  
  .note.hub .head {
    background: rgba(52,211,153,0.1);
  }
  
  /* Orphan notlar için özel stil */
  .note.orphan {
    border-color: var(--danger);
    opacity: 0.7;
  }
  
  .note.orphan .head {
    background: rgba(239,68,68,0.1);
  }
  
  
  
  /* Zoom durumunda bağlantı çizgilerinin kalınlığını ayarla */
  .board[style*="scale(0.5)"] .connection-line,
  .board[style*="scale(0.6)"] .connection-line,
  .board[style*="scale(0.7)"] .connection-line {
    height: 1px;
  }
  
  .board[style*="scale(1.5)"] .connection-line,
  .board[style*="scale(2)"] .connection-line,
  .board[style*="scale(2.5)"] .connection-line {
    height: 3px;
  }
  
  /* Zoom controls */
  .zoom-controls{position:absolute; top:10px; right:10px; display:flex; gap:4px; z-index:10}
  .zoom-btn{width:32px; height:32px; border:1px solid var(--border); background:var(--elev); color:var(--text); border-radius:8px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-size:16px; font-weight:bold;-webkit-app-region:no-drag}
  .zoom-btn:hover{background:rgba(255,255,255,.08)}
  .zoom-btn:active{transform:scale(0.95)}
  .zoom-info{position:absolute; top:10px; left:10px; background:var(--elev); border:1px solid var(--border); border-radius:8px; padding:6px 10px; color:var(--text); font-size:12px; z-index:10;-webkit-app-region:no-drag}

  /* Left Sidebar */
  .left-sidebar{display:flex;flex-direction:column;gap:10px}
  
  /* Folder system */
  .folder-controls {
    display: flex;
    gap: 8px;
    padding: 6px;
    border-bottom: 1px solid var(--border);
  }
  
  .folder-btn {
    flex: 1;
    padding: 8px 12px;
    border: 1px solid var(--border);
    background: var(--elev);
    color: var(--text);
    border-radius: 8px;
    cursor: pointer;
    font-size: 12px;
    text-align: center;
    -webkit-app-region: no-drag;
  }
  
  .folder-btn:hover {
    background: rgba(255,255,255,.08);
  }
  
  .folder-btn:active {
    transform: scale(0.95);
    background: rgba(255,255,255,.12);
  }
  
  .folder-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
  }
  
  .folder-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    margin-bottom: 4px;
    border: 1px solid transparent;
    -webkit-app-region: no-drag;
  }
  
  .folder-item:hover {
    background: rgba(255,255,255,.05);
  }
  
  .folder-item.active {
    background: rgba(125,211,252,.1);
    border-color: var(--accent);
  }
  
  .folder-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid var(--border);
    cursor: pointer;
  }
  
  .folder-name {
    flex: 1;
    font-size: 13px;
    color: var(--text);
  }
  
  .folder-count {
    font-size: 11px;
    color: var(--muted);
    background: var(--elev);
    padding: 2px 6px;
    border-radius: 12px;
  }
  
  .note-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    margin-left: 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    color: var(--muted);
    border: 1px solid transparent;
  }
  
  .note-item:hover {
    background: rgba(255,255,255,.03);
    color: var(--text);
  }
  
  .note-item.selected {
    background: rgba(125,211,252,.1);
    border-color: var(--accent);
    color: var(--text);
  }
  
  .note-item.dragging {
    opacity: 0.5;
    transform: scale(0.95);
  }
  
  .folder-item.drag-over {
    background: rgba(125,211,252,.2);
    border-color: var(--accent);
    transform: scale(1.02);
  }
  
  /* Folder Modal */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    -webkit-app-region: no-drag;
  }
  
  .modal-overlay.show {
    display: flex;
  }
  
  .modal {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    min-width: 320px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.4);
    -webkit-app-region: no-drag;
  }
  
  .modal-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 16px;
    text-align: center;
  }
  
  .modal-input {
    width: 100%;
    padding: 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--elev);
    color: var(--text);
    font-size: 14px;
    margin-bottom: 16px;
    outline: none;
    box-sizing: border-box;
    -webkit-app-region: no-drag;
  }
  
  .modal-input:focus {
    border-color: var(--accent);
    background: rgba(255,255,255,.08);
  }
  
  .color-picker {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 12px;
    margin-bottom: 20px;
      padding: 20px;
      background: rgba(0,0,0,0.1);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.05);
  }
  
  .color-option {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.1);
    cursor: pointer;
    transition: all 0.2s ease;
    -webkit-app-region: no-drag;
    position: relative;
    box-shadow: 
      0 4px 12px rgba(0,0,0,0.3),
      inset 0 1px 0 rgba(255,255,255,0.2);
  }
  
  .color-option:hover {
    transform: scale(1.15);
    border-color: rgba(255,255,255,0.4);
    box-shadow: 
      0 6px 20px rgba(0,0,0,0.4),
      0 0 0 2px rgba(255,255,255,0.2),
      inset 0 1px 0 rgba(255,255,255,0.3);
  }
  
  .color-option.selected {
    transform: scale(1.25);
    border-color: var(--accent);
    box-shadow: 
      0 8px 24px rgba(0,0,0,0.5),
      0 0 0 3px rgba(125,211,252,0.4),
      inset 0 1px 0 rgba(255,255,255,0.3);
  }
  
  .color-option.selected::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 16px;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
  }
  
  .modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
  }
  
  .modal-btn {
    padding: 10px 20px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--elev);
    color: var(--text);
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
    -webkit-app-region: no-drag;
  }
  
  .modal-btn:hover {
    background: rgba(255,255,255,.08);
  }
  
  .modal-btn.primary {
    background: var(--accent);
    color: #0b0f14;
    border-color: var(--accent);
  }
  
  .modal-btn.primary:hover {
    background: rgba(125,211,252,0.8);
  }

  /* Context Menu */
  .context-menu {
    position: fixed;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 4px 0;
    box-shadow: 0 8px 32px rgba(0,0,0,.3);
    z-index: 1000;
    min-width: 180px;
    -webkit-app-region: no-drag;
  }
  
  .context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    font-size: 13px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .context-menu-item:hover {
    background: rgba(255,255,255,.08);
  }
  
  .context-menu-separator {
    height: 1px;
    background: var(--border);
    margin: 4px 0;
  }

  /* Left Sidebar with Tabs */
  .left-sidebar{
    display:flex;
    flex-direction:column;
    gap:0;
    width: 280px;
    min-width: 280px;
    max-width: 280px;
    transition: all 0.3s ease;
    overflow: hidden;
    margin: 0;
    padding: 0;
  }
  
  .left-sidebar.hidden {
    width: 0;
    min-width: 0;
    opacity: 0;
  }
  
  /* Tab System */
  .tabs{display:flex;background:var(--elev);border:1px solid var(--border);border-bottom:none;border-radius:14px 14px 0 0;}
  .tab{flex:1;padding:8px 6px;text-align:center;font-size:11px;text-transform:uppercase;color:var(--muted);cursor:pointer;border-right:1px solid var(--border);transition:all 0.2s;-webkit-app-region:no-drag}
  .tab:last-child{border-right:none}
  .tab:hover{background:rgba(255,255,255,.04);color:var(--text)}
  .tab.active{background:var(--panel);color:var(--text);border-bottom:1px solid var(--panel)}
  
  /* Tab Content */
  .tab-content{background:var(--panel);border:1px solid var(--border);border-top:none;border-radius:0 0 14px 14px;flex:1;min-height:0;display:none;overflow-y:auto;padding:6px}
  .tab-content.active{display:flex;flex-direction:column}
  
  /* Tab content specific styles */
  #tab-map .miniwrap{padding:0}
  #tab-notes .folder-controls{margin-bottom:6px}
  
  /* Basit Etiket Sistemi */
  .tag-search{display:flex;gap:8px;margin-bottom:6px}
  .tag-search input{flex:1;background:var(--elev);border:1px solid var(--border);border-radius:8px;padding:8px 12px;color:var(--text);font-size:12px}
  .tag-search input:focus{outline:none;border-color:var(--accent)}
  .clear-search{background:var(--elev);border:1px solid var(--border);border-radius:6px;padding:6px 8px;color:var(--muted);cursor:pointer;font-size:10px;-webkit-app-region:no-drag}
  .clear-search:hover{background:var(--danger);color:white}
  
  /* Aktif Filtreler */
  .active-filters{margin-bottom:10px;min-height:24px}
  .filter-chip{display:inline-flex;align-items:center;gap:4px;background:var(--accent);color:#0b0f14;padding:4px 8px;border-radius:12px;font-size:11px;font-weight:500;margin:2px;-webkit-app-region:no-drag}
  .filter-chip-remove{cursor:pointer;opacity:0.7;margin-left:2px}
  .filter-chip-remove:hover{opacity:1}
  
  /* Etiket Kartları */
  .tag-cards{display:grid;grid-template-columns:1fr;gap:6px;max-height:400px;overflow-y:auto}
  
  /* Etiket Kartı */
  .tag-card{background:var(--elev);border:1px solid var(--border);border-radius:8px;padding:8px;cursor:pointer;transition:all 0.2s;-webkit-app-region:no-drag}
  .tag-card:hover{background:rgba(255,255,255,.04);border-color:var(--accent)}
  .tag-card.active{border-color:var(--accent);background:rgba(125,211,252,.05)}
  
  /* Kart Header */
  .tag-card-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  .tag-card-name{font-size:13px;font-weight:600;color:var(--text)}
  .tag-card-count{background:var(--panel);color:var(--muted);padding:2px 6px;border-radius:10px;font-size:10px}
  
  /* Kart Stats */
  .tag-card-stats{display:flex;gap:12px;margin-bottom:6px}
  .tag-stat{font-size:10px;color:var(--muted)}
  .tag-stat-value{color:var(--accent);font-weight:600}
  
  /* Kart Preview */
  .tag-card-preview{font-size:10px;color:var(--muted);line-height:1.3;overflow:hidden;text-overflow:ellipsis;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical}
  
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;overflow:hidden}
  .panel .title{font-size:12px;text-transform:uppercase;color:var(--muted);padding:8px 10px;border-bottom:1px solid var(--border)}
  .tags{display:flex;flex-wrap:wrap;gap:8px;padding:10px}
  .tags .tag{padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid var(--border);cursor:pointer;color:var(--muted);-webkit-app-region:no-drag}
  .tags .tag.active{outline:2px solid var(--accent);color:var(--text)}
  /* Bilgi Haritası */
  .minimap-container {
    position: relative;
    width: 100%;
    height: 160px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: var(--panel);
    overflow: hidden;
  }
  
  .minimap-viewport {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
  }
  
  .minimap-note {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent);
    border: 1px solid var(--accent2);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .minimap-note:hover {
    transform: scale(1.5);
    box-shadow: 0 0 8px rgba(125,211,252,0.6);
  }
  
  .minimap-note.selected {
    background: var(--accent2);
    border-color: var(--accent);
    transform: scale(1.3);
    box-shadow: 0 0 12px rgba(167,139,250,0.8);
  }
  
  .minimap-note.connected {
    background: var(--ok);
    border-color: var(--accent);
  }
  
  .minimap-note.hub {
    background: var(--ok);
    border-color: var(--accent);
    transform: scale(1.2);
  }
  
  .minimap-note.orphan {
    background: var(--danger);
    border-color: var(--danger);
    opacity: 0.7;
  }
  
  .minimap-connection {
    position: absolute;
    height: 1px;
    background: rgba(125,211,252,0.3);
    transform-origin: left center;
    pointer-events: none;
  }
  
  .minimap-connection.bidirectional {
    background: rgba(52,211,153,0.4);
  }
  
  .minimap-connection.strong {
    height: 2px;
    background: rgba(125,211,252,0.6);
  }
  
  .minimap-connection.weak {
    opacity: 0.2;
  }
  
  .minimap-zoom-indicator {
    position: absolute;
    top: 5px;
    right: 5px;
    background: var(--elev);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 10px;
    color: var(--text);
  }

  .minimap-folder {
    transition: opacity 0.2s ease;
  }

  .minimap-folder:hover {
    opacity: 1 !important;
  }

  .minimap-note {
    transition: border-color 0.2s ease;
  }

  .minimap-note:hover {
    border-color: var(--accent) !important;
  }
  
  /* Not listesi stilleri */
  .notelist-container {
    height: 200px;
    overflow-y: auto;
    padding: 8px;
  }
  
  .notelist-item {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--elev);
    margin-bottom: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .notelist-item:hover {
    border-color: var(--accent);
    background: rgba(255,255,255,.03);
  }
  
  .notelist-item.selected {
    border-color: var(--accent);
    background: rgba(125,211,252,.1);
    box-shadow: 0 0 0 2px rgba(125,211,252,.3);
  }
  
  .notelist-item .title {
    font-weight: 600;
    font-size: 13px;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  .notelist-item .snippet {
    font-size: 11px;
    color: var(--muted);
    line-height: 1.4;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }
  
  .notelist-item .meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 10px;
    color: var(--muted);
  }
  
  .notelist-item .tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }
  
  .notelist-item .tag {
    font-size: 9px;
    padding: 1px 4px;
    background: rgba(167,139,250,.2);
    color: var(--accent2);
    border-radius: 4px;
    border: 1px solid rgba(167,139,250,.3);
  }
  
  .notelist-item .date {
    font-size: 9px;
    color: var(--muted);
  }

    /* Note card */
  .note {
    position: absolute;
    min-width: 250px;
    min-height: 80px;
    width: 280px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: var(--panel);
    box-shadow: 0 2px 8px rgba(0,0,0,.15);
    overflow: hidden;
    cursor: grab;
    z-index: 2;
    user-select: none;
    -webkit-app-region: no-drag;
    display: flex;
    flex-direction: column;
    transition: none;
    contain: layout style;
    transform: translateZ(0);
    backface-visibility: hidden;
  }

  /* Klasör kartları için düz tasarım */
  .folder-card {
    position: absolute;
    width: 200px;
    height: 100px;
    border-radius: 12px;
    background: var(--panel);
    border: 1px solid var(--border);
    box-shadow: 0 2px 8px rgba(0,0,0,.1);
    cursor: grab;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    flex-direction: column;
    padding: 12px;
    z-index: 3;
    user-select: none;
    -webkit-user-select: none;
    -webkit-app-region: no-drag;
  }

  .folder-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,.15);
  }

  .folder-card:active {
    cursor: grabbing;
  }

  .folder-card.selected {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent), 0 4px 12px rgba(0,0,0,.15);
  }

  .folder-card .folder-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
  }

  .folder-card .folder-title {
    font-size: var(--title-font-size, 20px);
    font-weight: 600;
    color: var(--text);
    line-height: 1.4;
    word-wrap: break-word;
    flex: 1;
    transition: all 0.3s ease;
    overflow-wrap: break-word;
    hyphens: auto;
    white-space: normal;
  }

  /* Compact modda klasör başlığı daha büyük */
  .folder-card.compact .folder-title {
    font-size: var(--title-font-size, 32px);
    font-weight: 700;
    text-align: center;
    line-height: 1.2;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .folder-card.compact .folder-note-count {
    font-size: 14px;
  }

  .folder-card .folder-note-count {
    font-size: 11px;
    color: var(--muted);
    background: var(--elev);
    padding: 2px 6px;
    border-radius: 10px;
  }

  .folder-card .folder-color-indicator {
    width: 100%;
    height: 4px;
    border-radius: 2px;
    margin-top: auto;
  }

  /* Klasör-not bağlantı çizgileri */
  .folder-connection-line {
    position: absolute;
    height: 2px;
    background: var(--border);
    transform-origin: left center;
    z-index: -10;
    opacity: 0.6;
    transition: opacity 0.2s ease;
    pointer-events: none;
  }

  .folder-connection-line.strong {
    background: var(--accent);
    opacity: 0.8;
    height: 3px;
  }

  .folder-connection-line:hover {
    opacity: 1;
  }

  /* Context Menu */
  .context-menu {
    position: fixed;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,.3);
    z-index: 1000;
    min-width: 180px;
    padding: 4px 0;
    font-size: 13px;
  }

  .context-menu-item {
    padding: 8px 12px;
    cursor: pointer;
    color: var(--text);
    transition: background 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .context-menu-item:hover {
    background: var(--elev);
  }

  .context-menu-item.selected {
    background: rgba(125,211,252,0.1);
    color: var(--accent);
  }

  .context-menu-divider {
    height: 1px;
    background: var(--border);
    margin: 4px 0;
  }

  .note.compact:hover {
    opacity: 0.9;
  }

  /* Multi-selection sistemleri */
  .selection-box {
    position: absolute;
    border: 2px dashed var(--accent);
    background: rgba(125, 211, 252, 0.1);
    pointer-events: none;
    z-index: 1000;
    border-radius: 4px;
  }

  /* Delete confirmation modal */
  .delete-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    backdrop-filter: blur(4px);
  }

  .delete-modal-overlay.active {
    display: flex;
  }

  .delete-modal {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    min-width: 320px;
    max-width: 400px;
    box-shadow: 0 16px 48px rgba(0, 0, 0, 0.5);
    animation: deleteModalSlideIn 0.3s ease-out;
  }

  @keyframes deleteModalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .delete-modal-icon {
    text-align: center;
    font-size: 48px;
    margin-bottom: 16px;
  }

  .delete-modal-title {
    text-align: center;
    font-size: 20px;
    font-weight: 600;
    color: var(--text);
    margin-bottom: 8px;
  }

  .delete-modal-message {
    text-align: center;
    color: var(--muted);
    margin-bottom: 24px;
    line-height: 1.4;
  }

  .delete-modal-note-title {
    text-align: center;
    font-weight: 600;
    color: var(--accent);
    margin: 12px 0;
    padding: 8px 12px;
    background: rgba(125, 211, 252, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(125, 211, 252, 0.2);
  }

  .delete-modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .delete-modal-btn {
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 14px;
    min-width: 100px;
  }

  .delete-modal-btn.cancel {
    background: var(--elev);
    color: var(--text);
    border: 1px solid var(--border);
  }

  .delete-modal-btn.cancel:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: var(--accent);
  }

  .delete-modal-btn.delete {
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    border: 1px solid #dc2626;
  }

  .delete-modal-btn.delete:hover {
    background: linear-gradient(135deg, #dc2626, #b91c1c);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
  }

  .note.multi-selected {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 3px rgba(125,211,252,.8) !important;
    background: rgba(125, 211, 252, 0.15) !important;
    border-left: 4px solid var(--accent) !important;
    transform: scale(1.02) !important;
  }

  .note.multi-selected .head {
    background: rgba(125,211,252,.2) !important;
    border-bottom: 1px solid var(--accent) !important;
  }

  .note.selected {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(125,211,252,.3);
  }

  .note.dragging {
    z-index: 100;
    box-shadow: 0 8px 32px rgba(0,0,0,.4);
  }

  .note .head {
    height: 40px;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 12px;
    background: rgba(255,255,255,.05);
    border-bottom: 1px solid var(--border);
    cursor: grab;
    flex-shrink: 0;
  }

  /* Compact modda başlık daha büyük */
  .note.compact .head {
    height: 100%;
    background: rgba(255,255,255,.08);
    border-bottom: none;
    flex: 1;
    display: flex;
    align-items: center;
    padding: 12px;
  }
  
  .note.compact .tools {
    display: none;
  }

  .note .head:active {
    cursor: grabbing;
  }

  .note .title {
    flex: 1;
    font-weight: 600;
    font-size: var(--title-font-size, 20px);
    color: var(--text);
    transition: all 0.3s ease;
    line-height: 1.4;
    padding: 2px 0;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
    white-space: normal;
    overflow: visible;
    height: auto;
    max-height: none;
  }

  .note.compact .title {
    font-weight: 700;
    text-align: center;
    font-size: var(--title-font-size, 32px);
    line-height: 1.2;
    padding: 8px 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    white-space: normal;
    overflow: visible;
    word-wrap: break-word;
    overflow-wrap: break-word;
    hyphens: auto;
  }

  .note .tools {
    display: flex;
    gap: 4px;
    flex-shrink: 0;
  }

  .note .tools .mini {
    width: 24px;
    height: 24px;
    border: 1px solid var(--border);
    background: var(--elev);
    color: var(--text);
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    -webkit-app-region: no-drag;
  }

  .note .tools .mini:hover {
    background: var(--accent);
    color: #0b0f14;
  }

  .note .body {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-height: 0;
  }

  .note.compact .body {
    display: none;
  }

  .note .body .snippet {
    flex: 1;
    padding: 12px;
    color: var(--text);
    font-size: 20px;
    line-height: 1.5;
    overflow: hidden;
    word-wrap: break-word;
    white-space: pre-wrap;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 8;
  }
  
  /* Etiketler için yeni konum - başlık altında */
  .note .tags {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    padding: 8px 12px;
    background: rgba(255,255,255,.02);
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  
  .note.compact .tags {
    display: none;
  }
  
  .note .tags .tagtok {
    font-size: 18px;
    padding: 4px 8px;
    background: rgba(167,139,250,.2);
    color: var(--accent2);
    border-radius: 8px;
    border: 1px solid rgba(167,139,250,.3);
  }
  
  .resize {
    position: absolute;
    right: 8px;
    bottom: 8px;
    width: 16px;
    height: 16px;
    border-right: 2px solid var(--border);
    border-bottom: 2px solid var(--border);
    cursor: nwse-resize;
    z-index: 10;
    opacity: 0.6;
    transition: opacity 0.2s ease;
  }
  
  .resize:hover {
    opacity: 1;
  }
  
  /* Kart boyut değiştirme için özel stil */
  .note.resizing {
    transition: none !important;
  }
  
  .note.resizing .body {
    overflow: hidden;
  }
  
  /* Checklist stilleri */
  .checklist-item {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    padding: 4px 0;
    margin: 2px 0;
  }
  
  .checklist-checkbox {
    width: 18px;
    height: 18px;
    border: 2px solid var(--border);
    border-radius: 6px;
    background: var(--panel);
    cursor: pointer;
    flex-shrink: 0;
    margin-top: 1px;
    transition: all 0.3s ease;
    position: relative;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
  }
  
  .checklist-checkbox:hover {
    border-color: var(--accent);
    background: linear-gradient(135deg, rgba(125,211,252,0.1), rgba(125,211,252,0.05));
    box-shadow: 0 0 0 2px rgba(125,211,252,0.2), inset 0 1px 3px rgba(0,0,0,0.1);
    transform: scale(1.05);
  }
  
  .checklist-checkbox:checked {
    background: linear-gradient(135deg, var(--accent), #0ea5e9);
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(125,211,252,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
  }
  
  .checklist-checkbox:checked::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    color: white;
    font-weight: bold;
    font-size: 12px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
  }
  
  .checklist-text {
    flex: 1;
    line-height: 1.4;
    word-wrap: break-word;
  }
  
  .checklist-checkbox:checked + .checklist-text {
    text-decoration: line-through;
    opacity: 0.7;
  }

  /* Inspector (drawer) */
  /* Wikilink Autocomplete */
  .wikilink-autocomplete {
    position: absolute;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0,0,0,.3);
    backdrop-filter: blur(16px);
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    min-width: 200px;
  }
  
  .wikilink-autocomplete-item {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,.05);
    transition: background 0.2s ease;
  }
  
  .wikilink-autocomplete-item:hover,
  .wikilink-autocomplete-item.selected {
    background: rgba(125,211,252,.1);
  }
  
  .wikilink-autocomplete-item:last-child {
    border-bottom: none;
  }
  
  .wikilink-autocomplete-title {
    font-weight: 600;
    color: var(--text);
    font-size: 13px;
  }
  
  .wikilink-autocomplete-snippet {
    font-size: 11px;
    color: var(--muted);
    margin-top: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Zen Writing Mode */
  .zen-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #0b0f15 0%, #1a1f2e 50%, #0b0f15 100%);
    z-index: 10000;
    display: none;
    opacity: 0;
    transition: opacity 0.5s ease;
    -webkit-app-region: no-drag;
  }
  
  .zen-overlay.active {
    display: flex;
    opacity: 1;
  }
  
  .zen-container {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 60px 40px;
    box-sizing: border-box;
    position: relative;
  }
  
  .zen-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 40px;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.3s ease;
  }
  
  .zen-overlay.active .zen-header:hover {
    opacity: 1;
  }
  
  .zen-title {
    font-size: 16px;
    font-weight: 800;
    color: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    gap: 8px;
    text-shadow: 0 2px 8px rgba(139,92,246,0.6), 0 1px 4px rgba(0,0,0,0.3);
    filter: drop-shadow(0 0 8px rgba(125,211,252,0.4));
  }
  
  .zen-controls {
    display: flex;
    gap: 15px;
    font-size: 14px;
    color: #94a3b8;
  }
  
  .zen-control {
    opacity: 0.6;
    transition: opacity 0.3s ease;
  }
  
  .zen-control:hover {
    opacity: 1;
    color: #7dd3fc;
  }
  
  .zen-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    opacity: 0;
    transform: translateY(20px);
  }
  
  .zen-writing-area {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
    position: relative;
  }
  
  .zen-editor-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    border-radius: 8px;
  }
  
  .zen-title-input {
    background: none;
    border: none;
    outline: none;
    color: #e9eef5;
    font-size: 28px;
    font-weight: 600;
    font-family: 'Inter', sans-serif;
    padding: 0;
    margin: 0;
    line-height: 1.3;
    resize: none;
    overflow: hidden;
    min-height: 40px;
    -webkit-app-region: no-drag;
  }
  
  .zen-title-input::placeholder {
    color: #475569;
    font-weight: 300;
  }
  
  .zen-editor {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent;
    border: none;
    outline: none;
    color: transparent;
    caret-color: #7dd3fc;
    font-size: 18px;
    font-weight: 400;
    font-family: 'Inter', sans-serif;
    line-height: 1.6;
    padding: 20px;
    margin: 0;
    resize: none;
    z-index: 2;
    -webkit-app-region: no-drag;
  }
  
  .zen-editor::placeholder {
    color: #475569;
    font-style: italic;
  }
  
  .zen-editor:focus {
    outline: none;
  }
  
  .zen-highlight {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    color: #cbd5e1;
    font-size: 18px;
    font-weight: 400;
    font-family: 'Inter', sans-serif;
    line-height: 1.6;
    padding: 20px;
    margin: 0;
    pointer-events: none;
    z-index: 1;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow: hidden;
  }
  
  /* Syntax highlighting */
      .zen-highlight .tag {
      color: #a78bfa;
    }
  
      .zen-highlight .wikilink {
      color: #7dd3fc;
    }
  
  .zen-highlight .checkbox {
    color: #34d399;
    font-weight: 600;
    display: inline;
    line-height: inherit;
  }
  
  .zen-highlight .checkbox.checked {
    color: #7dd3fc;
    font-weight: 600;
    display: inline;
    line-height: inherit;
  }
  
  .zen-highlight .header {
    color: #e9eef5;
    font-weight: 600;
    display: inline;
    line-height: inherit;
  }
  
  .zen-highlight .header.h1 {
    font-size: 20px;
  }
  
  .zen-highlight .header.h2 {
    font-size: 19px;
  }
  
  .zen-highlight .header.h3 {
    font-size: 18px;
  }
  
  .zen-highlight .quote {
    color: #94a3b8;
    font-style: italic;
    display: inline;
    line-height: inherit;
  }
  
      .zen-highlight .code {
      color: #7dd3fc;
      font-family: 'JetBrains Mono', monospace;
      font-size: 18px;
    }
  
  .zen-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid rgba(125, 211, 252, 0.1);
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.3s ease;
  }
  
  .zen-overlay.active .zen-footer:hover {
    opacity: 1;
  }
  
  .zen-stats {
    font-size: 14px;
    color: #64748b;
    display: flex;
    gap: 20px;
  }
  
  .zen-actions {
    display: flex;
    gap: 15px;
  }
  
  .zen-btn {
    background: rgba(125, 211, 252, 0.1);
    border: 1px solid rgba(125, 211, 252, 0.2);
    color: #7dd3fc;
    border-radius: 8px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    -webkit-app-region: no-drag;
  }
  
  .zen-btn:hover {
    background: rgba(125, 211, 252, 0.2);
    border-color: rgba(125, 211, 252, 0.4);
    transform: translateY(-1px);
  }
  
  .zen-btn.primary {
    background: linear-gradient(135deg, #7dd3fc, #a78bfa);
    border-color: transparent;
    color: #0b0f15;
    font-weight: 600;
  }
  
  .zen-btn.primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(125, 211, 252, 0.3);
  }
  
  /* Zen Animations */
  @keyframes zenFadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .zen-overlay.active .zen-header {
    animation: zenFadeIn 0.6s ease forwards;
    animation-delay: 0.1s;
  }
  
  .zen-overlay.active .zen-header .zen-control {
    transition: none !important;
  }
  
  .zen-overlay.active .zen-content {
    animation: zenFadeIn 0.6s ease forwards;
    animation-delay: 0.2s;
  }
  
  .zen-overlay.active .zen-footer {
    animation: zenFadeIn 0.6s ease forwards;
    animation-delay: 0.3s;
  }
  
  .zen-overlay.active .zen-footer .zen-btn {
    transition: none !important;
  }

  /* Markdown bits */
  .md h2{font-size:16px; margin:6px 0; width:100%}
  .md p{margin:6px 0; width:100%; text-align:justify; word-wrap:break-word}
  .md blockquote{margin:6px 0; padding:6px 8px; border-left:3px solid #42506a; color:#c6d1e0; background:rgba(255,255,255,.035); border-radius:6px; width:100%; box-sizing:border-box}
  .md ul{list-style:none; padding:0; margin:6px 0; width:100%}
  .md li{display:flex; gap:8px; align-items:flex-start; padding:4px 0; width:100%}
  .md .cb{margin-top:2px}
  .md code{background:#0b1220; padding:2px 5px; border-radius:6px}
  .wikilink{color:#7dd3fc; text-decoration:underline; text-decoration-style:dotted; cursor:pointer}
  .tagtok{color:#a78bfa; font-weight:500}
  .highlight{background:rgba(125,211,252,.2); text-decoration:underline; text-decoration-style:dotted}

  /* Note list */
  .notelist{padding:10px; display:flex; flex-direction:column; gap:8px; overflow-y:auto}
  .notecard{border:1px solid var(--border); border-radius:12px; padding:12px; cursor:pointer; background:var(--elev); transition:all .2s}
  .notecard:hover{border-color:var(--accent); background:rgba(255,255,255,.03)}
  .notecard.selected{border-color:var(--accent); outline:2px solid var(--accent); background:rgba(125,211,252,.1)}
  .notecard .title{font-weight:700; margin-bottom:6px; color:var(--text)}
  .notecard .snippet{color:var(--muted); font-size:13px; line-height:1.4; margin-bottom:8px}
  .notecard .tags{display:flex; gap:4px; flex-wrap:wrap}
  .notecard .tag{font-size:11px; padding:2px 6px; background:rgba(167,139,250,.2); color:var(--accent2)}

  /* Graph */
  .graph{position:relative; width:100%; height:200px}
  .graph-node{position:absolute; width:40px; height:40px; border-radius:50%; background:var(--accent); display:grid; place-items:center; cursor:pointer; font-size:12px; font-weight:700; color:#0b0f14; border:2px solid var(--accent2)}
  .graph-node.center{background:var(--accent2); border-color:var(--accent); transform:scale(1.2)}
  .graph-node.neighbor{background:var(--elev); border-color:var(--border); color:var(--text); transform:scale(0.8)}
</style>
</head>
<body>
  <div class="widget" id="widget">
    <div class="top">
      <div class="drag">
        <div class="logo"><b>✦</b> Igo</div>
        <div class="search">
          <input type="text" id="q" placeholder="Ara (başlık, içerik, #etiket, [[link]])">
        </div>
      </div>
      <div class="toolbar">
        <button class="btn" id="toggleSidebarBtn" title="Paneli Gizle">☰</button>
        <button class="btn" id="newBtn">＋ Yeni</button>
        <button class="btn" id="closeBtn">✕</button>
      </div>
    </div>
    
    <div class="body">
      <!-- Sol Sidebar: Tab'lı Menü Paneli -->
      <div class="left-sidebar">
        <!-- Tab Headers -->
        <div class="tabs">
          <div class="tab active" data-tab="notes">Not Yönetimi</div>
          <div class="tab" data-tab="tags">Etiketler</div>
          <div class="tab" data-tab="map">Bilgi Haritası</div>
        </div>
        
        <!-- Tab Content: Not Yönetimi -->
        <div class="tab-content active" id="tab-notes">
          <div class="folder-controls">
            <button class="folder-btn" id="newNoteBtn" onclick="createNote();">📝 Yeni Not</button>
            <button class="folder-btn" id="newFolderBtn" onclick="createFolder();">📁 Yeni Klasör</button>
          </div>
          <div class="folder-list" id="folderList">
            <!-- Klasörler ve notlar buraya gelecek -->
          </div>
        </div>
        
        <!-- Tab Content: Etiketler -->
        <div class="tab-content" id="tab-tags">
          <!-- Arama -->
          <div class="tag-search">
            <input type="text" id="tagSearch" placeholder="🔍 Etiket ara...">
            <button class="clear-search" id="clearSearch">✕</button>
      </div>
      
          <!-- Aktif Filtreler -->
          <div class="active-filters" id="activeFilters">
            <!-- Aktif filtreler buraya gelecek -->
      </div>
      
          <!-- Etiket Kartları -->
          <div class="tag-cards" id="tagCards">
            <!-- Etiket kartları buraya gelecek -->
          </div>
        </div>
        
        <!-- Tab Content: Bilgi Haritası -->
        <div class="tab-content" id="tab-map">
          <div class="miniwrap">
            <div class="minimap-container" id="minimap">
              <div class="minimap-viewport">
                <!-- Notlar ve bağlantılar buraya gelecek -->
            </div>
          </div>
        </div>
      </div>
    </div>
    
      <!-- Sağ: Canvas -->
      <div class="boardwrap">
        <div class="boardbg"></div>
        <div id="board">
          <!-- Notlar buraya gelecek -->
        </div>
        <div class="zoom-info" id="zoomInfo">Zoom: 100%</div>
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoomOutBtn">−</button>
          <button class="zoom-btn" id="zoomInBtn">＋</button>
          <button class="zoom-btn" id="resetZoomBtn" title="Tüm Notları Göster">⌂</button>
        </div>
      </div>
    </div>
    
    
    <!-- Folder Modal -->
    <div class="modal-overlay" id="folderModal" onclick="closeFolderModal()">
      <div class="modal" onclick="event.stopPropagation()">
        <div class="modal-title">📁 Yeni Klasör Oluştur</div>
        <input type="text" class="modal-input" id="folderNameInput" placeholder="Klasör adını girin..." maxlength="50">
        
        <div class="color-picker" id="colorPicker">
          <!-- Renkler JavaScript ile oluşturulacak -->
        </div>
        
        <div class="modal-buttons">
          <button class="modal-btn" onclick="closeFolderModal()">İptal</button>
          <button class="modal-btn primary" onclick="confirmCreateFolder()">Oluştur</button>
        </div>
      </div>
    </div>
    
    <!-- Delete Confirmation Modal -->
    <div class="delete-modal-overlay" id="deleteModalOverlay">
      <div class="delete-modal">
        <div class="delete-modal-icon">🗑️</div>
        <div class="delete-modal-title">Notu Sil</div>
        <div class="delete-modal-message">Bu notu silmek istediğinizden emin misiniz?</div>
        <div class="delete-modal-note-title" id="deleteModalNoteTitle">Not Başlığı</div>
        <div class="delete-modal-buttons">
          <button class="delete-modal-btn cancel" onclick="closeDeleteModal()">İptal</button>
          <button class="delete-modal-btn delete" onclick="confirmDeleteNote()">Sil</button>
        </div>
      </div>
    </div>
    
    <!-- Zen Writing Mode -->
    <div class="zen-overlay" id="zenOverlay">
      <div class="zen-container">
        <div class="zen-header">
          <div class="zen-title">
            <span style="font-size:18px;font-weight:900;text-shadow:0 2px 8px rgba(139,92,246,0.6),0 1px 4px rgba(0,0,0,0.3);filter:drop-shadow(0 0 8px rgba(125,211,252,0.4));">✦</span>
            Igo
          </div>
          <div class="zen-controls">
            <span class="zen-control">ESC - Çıkış</span>
            <span class="zen-control">Ctrl+S - Kaydet</span>
          </div>
        </div>
        
        <div class="zen-content">
          <textarea 
            class="zen-title-input" 
            id="zenTitleInput" 
            placeholder="Fikrini başlık olarak yaz..."
            rows="1"
            maxlength="200"
          ></textarea>
          
          <div class="zen-writing-area">
            <div class="zen-editor-container">
              <div class="zen-highlight" id="zenHighlight"></div>
              <textarea 
                class="zen-editor" 
                id="zenBodyInput" 
                placeholder="Burada düşüncelerini özgürce ifade et...

• - [ ] ile checkbox oluştur
• #etiket ile etiketler ekle  
• [[bağlantı]] ile notları bağla
• Sadece yazmaya odaklan!"
              ></textarea>
            </div>
          </div>
        </div>
        
        <div class="zen-footer">
          <div class="zen-stats">
            <span id="zenWordCount">0 kelime</span>
            <span id="zenCharCount">0 karakter</span>
            <span id="zenLineCount">1 satır</span>
          </div>
          <div class="zen-actions">
            <button class="zen-btn" id="zenCancelBtn">İptal</button>
            <button class="zen-btn primary" id="zenSaveBtn">Kaydet & Kapat</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Veri yapısı
let notes = [];
let folders = [];
let selectedNote = null;
let selectedFolder = null;
let activeTag = 'all';
let searchQuery = '';
let expandedFolders = []; // Açık klasörler

// Multi-selection sistemi
let selectedNotes = []; // Seçili notlar
let isSelecting = false; // Selection box durumu
let selectionStartX = 0;
let selectionStartY = 0;
let selectionBox = null;

// Delete modal sistemi
let noteToDelete = null;

// Graph görünüm ayarları
let graphSettings = {
  showHubs: false,
  showOrphans: false
};

  // Modern renk paleti - Expanded & Professional
const FOLDER_COLORS = [
    // Mavi Tonları
    '#3b82f6', '#06b6d4', '#0ea5e9', '#7dd3fc', '#38bdf8',
    // Mor Tonları  
    '#8b5cf6', '#a78bfa', '#c084fc', '#6366f1', '#8b5cf6',
    // Yeşil Tonları
    '#10b981', '#34d399', '#22d3ee', '#4ade80', '#16a34a',
    // Kırmızı/Pembe Tonları
    '#ef4444', '#f43f5e', '#ec4899', '#fb7185', '#e11d48',
    // Turuncu/Sarı Tonları
    '#f59e0b', '#f97316', '#fb923c', '#fbbf24', '#eab308',
    // Neutral Tonları
    '#64748b', '#6b7280', '#374151', '#1f2937', '#111827',
    // Pastel Tonları
    '#fde047', '#a7f3d0', '#fed7d7', '#ddd6fe', '#f3e8ff'
];

// Zoom ve pan değişkenleri
let boardZoom = 1;
let boardPanX = 0;
let boardPanY = 0;
let isDragging = false;
let isPanning = false;
let lastMouseX = 0;
let lastMouseY = 0;
let lastPanX = 0;
  let lastPanY = 0;
  let isMiddleMouseDown = false;

// Zoom fonksiyonları
function zoomIn() {
  boardZoom = Math.min(boardZoom * 1.2, 3);
  updateBoardTransform();
  renderNotes(); // Notları ve klasörleri yeniden render et
}

function zoomOut() {
  boardZoom = Math.max(boardZoom / 1.2, 0.1);
  updateBoardTransform();
  renderNotes(); // Notları ve klasörleri yeniden render et
}

function updateBoardTransform() {
  const board = document.getElementById('board');
  if (board) {
    board.style.transform = `scale(${boardZoom}) translate(${boardPanX}px, ${boardPanY}px)`;
  }
  
  // Zoom info'yu güncelle
  const zoomInfo = document.getElementById('zoomInfo');
  if (zoomInfo) {
    zoomInfo.textContent = `Zoom: ${Math.round(boardZoom * 100)}%`;
  }
}

  // LocalStorage anahtarları
const STORAGE_KEYS = {
  NOTES: 'obsidian_widget.notes.v1',
  FOLDERS: 'obsidian_widget.folders.v1',
  ORB_POS: 'obsidian_widget.orbpos',
  PANEL_RECT: 'obsidian_widget.panelrect'
};

// Regex'ler
const REGEX = {
  TAGS: /(\^|\s)#([a-z0-9ğüşiöçıİ\-]+)/ig,
  WIKILINKS: /\[\[([^\]]+)\]\]/g,
  CHECKLIST: /^\s*-\s*\[( |x|X)\]\s*(.*)$/
};

// Utility fonksiyonlar
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function parseTags(text) {
  const tags = [];
  let match;
  while ((match = REGEX.TAGS.exec(text)) !== null) {
    tags.push(match[2].toLowerCase());
  }
  return [...new Set(tags)];
}

function parseWikilinks(text) {
  const links = [];
  let match;
  while ((match = REGEX.WIKILINKS.exec(text)) !== null) {
    links.push(match[1].trim());
  }
  return [...new Set(links)];
}

function highlightText(text, query) {
  if (!query) return escapeHtml(text);
  const regex = new RegExp(`(${escapeHtml(query)})`, 'gi');
  return escapeHtml(text).replace(regex, '<span class="highlight">$1</span>');
}

// Markdown render - Düzeltilmiş
function renderMarkdown(text) {
  if (!text) return '';
  
  let html = escapeHtml(text);
  
  // Başlıklar
  html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');
  
  // Alıntılar
  html = html.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');
  
  // Checklist - İnteraktif checkboxlar
  html = html.replace(/^\s*-\s*\[\s*\]\s*(.*)$/gm, 
    '<div class="checklist-item"><input type="checkbox" class="checklist-checkbox"><span class="checklist-text">$1</span></div>');
  html = html.replace(/^\s*-\s*\[x\]\s*(.*)$/gmi, 
    '<div class="checklist-item"><input type="checkbox" class="checklist-checkbox" checked><span class="checklist-text">$1</span></div>');
  
  // Satır sonları
  html = html.replace(/\n/g, '<br>');
  
  // Inline formatlar
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  html = html.replace(/`(.+?)`/g, '<code>$1</code>');
  
  // Etiketler
  html = html.replace(/#([a-z0-9ğüşiöçıİ\-]+)/g, '<span class="tagtok">#$1</span>');
  
  // Wikilinks
  html = html.replace(/\[\[([^\]]+)\]\]/g, '<span class="wikilink" data-link="$1">[[$1]]</span>');
  
  return html;
}

// LocalStorage işlemleri
function saveNotes() {
  localStorage.setItem(STORAGE_KEYS.NOTES, JSON.stringify(notes));
}

function loadNotes() {
  const saved = localStorage.getItem(STORAGE_KEYS.NOTES);
  if (saved) {
    notes = JSON.parse(saved);
  } else {
    // Örnek notlar
    notes = [
      {
        id: generateId(),
        title: 'Hoş Geldiniz',
        text: 'Bu bir örnek nottur.\n\n- [ ] İlk görev\n- [x] Tamamlanan görev\n\n#örnek #başlangıç\n\n[[Başka Not]]',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        tags: ['örnek', 'başlangıç'],
        links: ['Başka Not'],
        folderId: null
      },
      {
        id: generateId(),
        title: 'Başka Not',
        text: 'Bu da başka bir nottur.\n\n#örnek',
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        tags: ['örnek'],
        links: [],
        folderId: null
      }
    ];
    saveNotes();
  }
}

// Klasörleri localStorage'a kaydet
function saveFolders() {
  try {
    localStorage.setItem(STORAGE_KEYS.FOLDERS, JSON.stringify(folders));
  } catch (error) {
  }
}

// Klasörleri localStorage'dan yükle
function loadFolders() {
  try {
    const saved = localStorage.getItem(STORAGE_KEYS.FOLDERS);
    if (saved) {
      folders = JSON.parse(saved);
    } else {
      // Varsayılan klasör oluştur
      folders = [{
        id: generateId(),
        name: 'Genel Notlar',
        color: FOLDER_COLORS[0],
        createdAt: new Date().toISOString()
      }];
      saveFolders();
    }
  } catch (error) {
    folders = [{
      id: generateId(),
      name: 'Genel Notlar',
      color: FOLDER_COLORS[0],
      createdAt: new Date().toISOString()
    }];
  }
}

// Not işlemleri
function createNote(folderId = null) {
  const note = {
    id: generateId(),
    title: 'Başlıksız Not',
    text: '',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    tags: [],
    links: [],
    folderId: null // Her yeni not klasörsüz olarak oluşturulur
  };
  
  notes.unshift(note);
  saveNotes();
  renderNotes();
  renderTags();
  renderFolderList();
  selectNote(note.id);
  
  // Zen Mode ile aç
  openZenMode(note.id);
}

// Klasör işlemleri
let selectedColor = FOLDER_COLORS[0]; // Varsayılan renk

function createFolder() {
  openFolderModal();
}

function openFolderModal() {
  const modal = document.getElementById('folderModal');
  const nameInput = document.getElementById('folderNameInput');
  const colorPicker = document.getElementById('colorPicker');
  
  // Modal'ı göster
  modal.classList.add('show');
  
  // Renk seçicisini oluştur
  colorPicker.innerHTML = '';
  FOLDER_COLORS.forEach((color, index) => {
    const colorOption = document.createElement('div');
    colorOption.className = `color-option ${index === 0 ? 'selected' : ''}`;
    colorOption.style.background = color;
    colorOption.onclick = () => selectColor(color, colorOption);
    colorPicker.appendChild(colorOption);
  });
  
  // İlk rengi seç
  selectedColor = FOLDER_COLORS[0];
  
  // Input'a focus
  setTimeout(() => nameInput.focus(), 100);
  
  // ESC ile kapatma
  document.addEventListener('keydown', handleModalKeydown);
}

function selectColor(color, element) {
  selectedColor = color;
  
  // Önceki seçimi temizle
  document.querySelectorAll('.color-option').forEach(el => {
    el.classList.remove('selected');
  });
  
  // Yeni seçimi işaretle
  element.classList.add('selected');
}

function handleModalKeydown(e) {
  if (e.key === 'Escape') {
    closeFolderModal();
  } else if (e.key === 'Enter') {
    confirmCreateFolder();
  }
}

function closeFolderModal() {
  const modal = document.getElementById('folderModal');
  const nameInput = document.getElementById('folderNameInput');
  
  modal.classList.remove('show');
  nameInput.value = '';
  
  // Event listener'ı kaldır
  document.removeEventListener('keydown', handleModalKeydown);
}

function confirmCreateFolder() {
  const nameInput = document.getElementById('folderNameInput');
  const name = nameInput.value.trim();
  
  if (!name) {
    // Input'u highlight et
    nameInput.style.borderColor = 'var(--danger)';
    nameInput.focus();
    setTimeout(() => {
      nameInput.style.borderColor = '';
    }, 2000);
    return;
  }
  
  const folder = {
    id: generateId(),
    name: name,
    color: selectedColor,
    createdAt: new Date().toISOString()
  };
  
  folders.push(folder);
  saveFolders();
  renderFolderList();
  renderNotes(); // Board üzerindeki klasörleri de güncelle
  closeFolderModal();
  
}

function toggleFolder(folderId) {
  if (expandedFolders.includes(folderId)) {
    expandedFolders = expandedFolders.filter(id => id !== folderId);
  } else {
    expandedFolders.push(folderId);
  }
  renderFolderList();
}

function toggleAllFolders() {
  // Tüm klasör ID'lerini al (orphan dahil)
  const allFolderIds = ['orphan', ...folders.map(f => f.id)];
  
  // Eğer tüm klasörler açıksa, hepsini kapat
  const allExpanded = allFolderIds.every(id => expandedFolders.includes(id));
  
  if (allExpanded) {
    expandedFolders = []; // Hepsini kapat
  } else {
    expandedFolders = [...allFolderIds]; // Hepsini aç
  }
  
  renderFolderList();
}

function selectFolder(folderId) {
  selectedFolder = folderId;
  
  // Board üzerindeki klasör kartların seçim durumunu güncelle
  document.querySelectorAll('.folder-card').forEach(folderEl => {
    folderEl.classList.remove('selected');
  });
  
  if (folderId) {
    const selectedFolderEl = document.getElementById(`folder-${folderId}`);
    if (selectedFolderEl) {
      selectedFolderEl.classList.add('selected');
    }
  }
  
  // Not seçimini temizle (klasör seçilince)
  selectedNote = null;
  document.querySelectorAll('.note').forEach(noteEl => {
    noteEl.classList.remove('selected');
  });
  
  renderFolderList();
  renderNotes();
  renderGraph();
}

function getFolderNotes(folderId) {
  return notes.filter(note => note.folderId === folderId);
}

function changeNoteFolder(noteId, newFolderId) {
  const note = notes.find(n => n.id === noteId);
  if (note) {
    note.folderId = newFolderId;
    note.updatedAt = new Date().toISOString();
    saveNotes();
    renderFolderList();
    renderNotes();
  }
}

function deleteFolder(folderId) {
  const folder = folders.find(f => f.id === folderId);
  if (!folder) return;
  
  if (confirm(`"${folder.name}" klasörü silinsin mi?\n\nKlasördeki notlar klasörsüz hale gelecek.`)) {
    // Klasördeki notları klasörsüz yap
    notes.forEach(note => {
      if (note.folderId === folderId) {
        note.folderId = null;
      }
    });
    
    // Klasörü sil
    folders = folders.filter(f => f.id !== folderId);
    
    // Seçili klasör silinmişse, null yap
    if (selectedFolder === folderId) {
      selectedFolder = null;
    }
    
    saveNotes();
    saveFolders();
    renderFolderList();
    renderNotes();
    
  }
}

function updateNote(id, title, text) {
  const note = notes.find(n => n.id === id);
  if (note) {
    note.title = title;
    note.text = text;
    note.updatedAt = new Date().toISOString();
    note.tags = parseTags(text);
    note.links = parseWikilinks(text);
    saveNotes();
    renderNotes();
      renderTags();
    renderGraph();
  }
}

function deleteNote(id) {
  const note = notes.find(n => n.id === id);
  if (!note) return;
  
  // Modal'ı aç
  noteToDelete = id;
  const deleteModalOverlay = document.getElementById('deleteModalOverlay');
  const deleteModalNoteTitle = document.getElementById('deleteModalNoteTitle');
  
  deleteModalNoteTitle.textContent = note.title || 'Başlıksız Not';
  deleteModalOverlay.classList.add('active');
}

function selectNote(id) {
  selectedNote = id;
  
  // Board üzerindeki not kartların seçim durumunu güncelle
  document.querySelectorAll('.note').forEach(noteEl => {
    noteEl.classList.remove('selected');
  });
  
  if (id) {
    const selectedNoteEl = document.getElementById(`note-${id}`);
    if (selectedNoteEl) {
      selectedNoteEl.classList.add('selected');
    }
  }
  
  // Klasör seçimini temizle (not seçilince)
  selectedFolder = null;
  document.querySelectorAll('.folder-card').forEach(folderEl => {
    folderEl.classList.remove('selected');
  });
  
  renderNotes();
  renderGraph();
  renderNoteList();
  renderFolderList();
  
  if (id) {
    const note = notes.find(n => n.id === id);
    if (note) {
      const titleInput = document.getElementById('titleIn');
      const bodyInput = document.getElementById('bodyIn');
      
      if (titleInput) {
        titleInput.value = note.title;
      }
      
      if (bodyInput) {
        bodyInput.value = note.text;
      }
      
      renderPreview();
    }
  }
}

// Not düzenleme fonksiyonu
function editNote(noteId) {
  selectNote(noteId);
  openZenMode(noteId); // Doğrudan noteId'yi geç
}

// Delete modal fonksiyonları
function closeDeleteModal() {
  const deleteModalOverlay = document.getElementById('deleteModalOverlay');
  deleteModalOverlay.classList.remove('active');
  noteToDelete = null;
}

function confirmDeleteNote() {
  if (noteToDelete) {
    // Gerçek silme işlemi
    notes = notes.filter(n => n.id !== noteToDelete);
    saveNotes();
    
    if (selectedNote === noteToDelete) {
      selectedNote = null;
    }
    
    // Multi-selection'dan da kaldır
    selectedNotes = selectedNotes.filter(id => id !== noteToDelete);
    
    renderNotes();
    renderTags();
    renderGraph();
    
    // Modal'ı kapat
    closeDeleteModal();
  }
}

// Zoom ve pan fonksiyonları
function updateBoardTransform() {
  const board = document.getElementById('board');
  
  // Canvas'a zoom ve pan uygula
  const transform = `translate(${boardPanX}px, ${boardPanY}px) scale(${boardZoom})`;
  board.style.transform = transform;
  
  // Zoom bilgisini güncelle
  const zoomInfo = document.getElementById('zoomInfo');
  if (zoomInfo) {
    zoomInfo.textContent = `Zoom: ${Math.round(boardZoom * 100)}%`;
  }
  
  // Notların pozisyonlarını sabit tut (zoom canvas'a uygulandığı için)
  notes.forEach(note => {
    if (note.x !== undefined && note.y !== undefined) {
      const element = document.getElementById(`note-${note.id}`);
      if (element && !element.classList.contains('dragging')) {
        element.style.left = note.x + 'px';
        element.style.top = note.y + 'px';
        element.style.transform = 'none'; // Transform'u sıfırla
      }
    }
  });
  
  // Board'un boyutunu dinamik olarak ayarla
  updateBoardSize();
  
  // Kartları yeniden render et (compact mod için)
  renderNotes();
  
  // Bağlantıları yeniden çiz
  drawConnections();
  
  // Minimap'i güncelle
  renderGraph();
}

// Board boyutunu dinamik olarak güncelle
function updateBoardSize() {
  const board = document.getElementById('board');
  
  if (notes.length === 0) {
    board.style.width = '100%';
    board.style.height = '100%';
    return;
  }
  
  // Notların sınırlarını hesapla
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  notes.forEach(note => {
    if (note.x !== undefined && note.y !== undefined) {
      minX = Math.min(minX, note.x);
      minY = Math.min(minY, note.y);
      
      // Not boyutlarını hesapla
      let noteWidth = 280;
      let noteHeight = getNoteHeight(note);
      
      if (note.customWidth) {
        noteWidth = note.customWidth;
      }
      if (note.customHeight) {
        noteHeight = note.customHeight;
      }
      
      maxX = Math.max(maxX, note.x + noteWidth);
      maxY = Math.max(maxY, note.y + noteHeight);
    }
  });
  
  // Eğer hiç not yoksa varsayılan değerler
  if (minX === Infinity) {
    minX = 0; minY = 0; maxX = 800; maxY = 600;
  }
  
  // Board boyutlarını ayarla (padding ile)
  const padding = 100;
  const boardWidth = Math.max(maxX - minX + padding * 2, 800);
  const boardHeight = Math.max(maxY - minY + padding * 2, 600);
  
  board.style.width = boardWidth + 'px';
  board.style.height = boardHeight + 'px';
  
}

function zoomIn() {
  boardZoom = Math.min(boardZoom * 1.2, 3);
  updateBoardTransform();
}

function zoomOut() {
  boardZoom = Math.max(boardZoom / 1.2, 0.1);
  updateBoardTransform();
}

function toggleSidebar() {
  const sidebar = document.querySelector('.left-sidebar');
  const body = document.querySelector('.body');
  
  sidebar.classList.toggle('hidden');
  body.classList.toggle('sidebar-hidden');
  
  // Button icon'unu değiştir
  const toggleBtn = document.getElementById('toggleSidebarBtn');
  if (sidebar.classList.contains('hidden')) {
    toggleBtn.textContent = '→'; // Sağ ok - sidebar kapalı
    toggleBtn.title = 'Paneli Aç';
  } else {
    toggleBtn.textContent = '☰'; // Hamburger - sidebar açık
    toggleBtn.title = 'Paneli Gizle';
  }
}

function fitAllNotes() {
  
  if (notes.length === 0) {
    // Not yoksa center'a git
  boardZoom = 1;
  boardPanX = 0;
  boardPanY = 0;
  updateBoardTransform();
    return;
  }

  // Tüm notların sınırlarını bul
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  notes.forEach(note => {
    const x = note.x || 0;
    const y = note.y || 0;
    
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + 300); // Not kartı genişliği ~300px
    maxY = Math.max(maxY, y + 200); // Not kartı yüksekliği sabit 200px
  });
  
  
  // Boardwrap boyutlarını al
  const boardwrap = document.querySelector('.boardwrap');
  const containerWidth = boardwrap.clientWidth;
  const containerHeight = boardwrap.clientHeight;
  
  
  // İçerik boyutlarını hesapla
  const contentWidth = maxX - minX;
  const contentHeight = maxY - minY;
  
  // Padding ekle (kenarlardan boşluk)
  const padding = 100;
  
  // Zoom seviyesini hesapla (tüm notlar görünecek şekilde)
  const zoomX = (containerWidth - padding * 2) / contentWidth;
  const zoomY = (containerHeight - padding * 2) / contentHeight;
  
  // En küçük zoom'u kullan ama minimum ve maksimum sınırlar koy
  boardZoom = Math.max(0.1, Math.min(2, Math.min(zoomX, zoomY)));
  
  // Tüm notların merkez noktasını hesapla
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  // Board'u tüm notları gösterecek şekilde konumlandır
  boardPanX = (containerWidth / 2) - (centerX * boardZoom);
  boardPanY = (containerHeight / 2) - (centerY * boardZoom);
  
  
  updateBoardTransform();
}


// Not yüksekliğini hesapla
function getNoteHeight(note) {
  const contentLength = note.text.length;
  const titleLength = note.title.length;
  
  // Başlık uzunluğuna göre minimum yükseklik hesapla
  let minHeightForTitle = 160; // Base minimum
  if (titleLength > 20) {
    minHeightForTitle = 180; // Uzun başlık için
  }
  if (titleLength > 40) {
    minHeightForTitle = 200; // Çok uzun başlık için
  }
  
  // İçerik uzunluğuna göre yükseklik
  let noteHeight = minHeightForTitle;
  
  if (contentLength > 300) {
    noteHeight = Math.max(noteHeight, 240);
  }
  if (contentLength > 600) {
    noteHeight = Math.max(noteHeight, 300);
  }
  if (contentLength > 1200) {
    noteHeight = Math.max(noteHeight, 360);
  }
  
  return noteHeight;
}

// Not detayını aç
function openNoteDetail(noteId) {
  selectNote(noteId);
  openZenMode(noteId); // Doğrudan noteId'yi geç
}


function centerOnNote(noteId) {
  // Önce note objesini bul
  const note = notes.find(n => n.id === noteId);
  if (!note || note.x === undefined || note.y === undefined) return;
  
  const boardwrap = document.querySelector('.boardwrap');
  if (!boardwrap) return;
  
  const boardwrapRect = boardwrap.getBoundingClientRect();
  
  // Note'un gerçek boyutlarını hesapla
  const noteWidth = note.customWidth || 280;
  const noteHeight = note.customHeight || getNoteHeight(note);
  
  // Notun merkez koordinatları (stored x,y + half size)
  const noteCenterX = note.x + noteWidth / 2;
  const noteCenterY = note.y + noteHeight / 2;
  
  // Boardwrap'in merkez koordinatları
  const viewportCenterX = boardwrapRect.width / 2;
  const viewportCenterY = boardwrapRect.height / 2;
  
  // Pan değerlerini hesapla (notun merkezini viewport merkezine getir)
  boardPanX = viewportCenterX - (noteCenterX * boardZoom);
  boardPanY = viewportCenterY - (noteCenterY * boardZoom);
  
  updateBoardTransform();
}

// Render fonksiyonları
function renderNotes() {
  const board = document.getElementById('board');
  
  // Board'ı temizle
  board.innerHTML = '';
  
  // Önce bağlantı çizgilerini çiz (en altta olması için)
  // Bu boş geçer, sonra güncellenecek
  
  // Sonra klasörleri render et
  renderFoldersOnBoard();
  
  const filteredNotes = notes.filter(note => {
    const matchesSearch = !searchQuery || 
      note.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      note.text.toLowerCase().includes(searchQuery.toLowerCase()) ||
      note.tags.some(tag => tag.includes(searchQuery.toLowerCase()));
    
    // Aktif etiket filtreleri kontrolü (tüm seçili etiketler notda bulunmalı)
    const matchesTagFilters = activeTagFilters.length === 0 || 
      activeTagFilters.every(filter => note.tags.includes(filter));
    
    return matchesSearch && matchesTagFilters;
  });
  
  // Notları board üzerinde konumlandır
  filteredNotes.forEach((note, index) => {
    const card = document.createElement('div');
    card.className = `note ${note.id === selectedNote ? 'selected' : ''} ${boardZoom < 0.2 ? 'compact' : ''}`;
    card.id = `note-${note.id}`;
    
    // Pozisyon hesapla
    let x, y;
    if (note.x !== undefined && note.y !== undefined) {
      // Kaydedilmiş pozisyon varsa kullan
      x = note.x;
      y = note.y;
    } else {
      // Klasöre göre pozisyonlandır
      const folder = folders.find(f => f.id === note.folderId);
      if (folder && folder.x !== undefined && folder.y !== undefined) {
        // Klasör varsa onun altına yerleştir
        const folderNotes = filteredNotes.filter(n => n.folderId === note.folderId);
        const noteIndexInFolder = folderNotes.indexOf(note);
        const notesPerRow = 2; // Her satırda 2 not
        const row = Math.floor(noteIndexInFolder / notesPerRow);
        const col = noteIndexInFolder % notesPerRow;
        
        x = folder.x + col * 300; // Yan yana notlar
        y = folder.y + 120 + row * 180; // Klasörün altında
      } else {
        // Klasörsüz notlar veya klasör pozisyonu yoksa
        const orphanNotes = filteredNotes.filter(n => !n.folderId);
        const orphanIndex = orphanNotes.indexOf(note);
        if (orphanIndex >= 0) {
          // Klasörsüz notları sağ alt köşeye yerleştir
          const cols = Math.ceil(Math.sqrt(orphanNotes.length));
          const row = Math.floor(orphanIndex / cols);
          const col = orphanIndex % cols;
          x = 400 + folders.length * 200 + col * 300;
          y = 300 + row * 180;
        } else {
          // Varsayılan grid
          const cols = Math.ceil(Math.sqrt(filteredNotes.length));
          const row = Math.floor(index / cols);
          const col = index % cols;
          x = 50 + col * 280;
          y = 50 + row * 160;
        }
      }
      // Pozisyonu kaydet
      note.x = x;
      note.y = y;
    }
    
    card.style.left = x + 'px';
    card.style.top = y + 'px';
    card.style.transform = 'none'; // Transform'u sıfırla
    
    // Klasör rengini uygula
    const folder = folders.find(f => f.id === note.folderId);
    if (folder) {
      // RGB değerini hex'ten çıkar
      const hex = folder.color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // Tamamen opak kart tasarımı
      card.style.background = `var(--panel)`;
      card.style.borderColor = `rgba(${r},${g},${b},0.6)`;
      card.style.boxShadow = `0 2px 8px rgba(0,0,0,.1)`;
      
      // Klasör rengi için sol kenarda ince çizgi ekle
      card.style.borderLeft = `4px solid ${folder.color}`;
      
      // Header'a subtle renk ekle (sadeleştirilmiş)
      setTimeout(() => {
        const head = card.querySelector('.head');
        if (head) {
          head.style.background = `rgba(${r},${g},${b},0.1)`;
          head.style.borderBottom = `1px solid rgba(${r},${g},${b},0.15)`;
        }
      }, 10);
    } else {
      // Klasörsüz notlar için opak arka plan
      card.style.background = `var(--panel)`;
    }
    
    // Not içeriğini render et
    const renderedContent = renderMarkdown(note.text);
    
    // Not boyutlarını ayarla (özel boyut varsa kullan, yoksa içeriğe göre)
    let noteWidth = 280;
    let noteHeight = getNoteHeight(note);
    
    if (note.customWidth) {
      noteWidth = note.customWidth;
    }
    if (note.customHeight) {
      noteHeight = note.customHeight;
    }
    
    // Sabit boyutları kullan (zoom canvas'a uygulanıyor)
    card.style.width = noteWidth + 'px';
    
    // Compact modunu belirle
    const isCompact = boardZoom < 0.3;
    
    if (isCompact) {
      // Compact modda: Dinamik yükseklik hesaplama
      // Zoom 0.1'de 50px, Zoom 0.3'te 30px
      const fontSize = Math.max(30, 30 + (0.3 - boardZoom) * 400);
      
      const tempDiv = document.createElement('div');
      tempDiv.style.visibility = 'hidden';
      tempDiv.style.position = 'absolute';
      tempDiv.style.width = (noteWidth - 24) + 'px'; // padding dahil
      tempDiv.style.fontSize = fontSize + 'px';
      tempDiv.style.fontWeight = '700';
      tempDiv.style.lineHeight = '1.2';
      tempDiv.style.wordWrap = 'break-word';
      tempDiv.style.overflowWrap = 'break-word';
      tempDiv.style.hyphens = 'auto';
      tempDiv.style.whiteSpace = 'normal';
      tempDiv.textContent = note.title;
      
      document.body.appendChild(tempDiv);
      const textHeight = tempDiv.offsetHeight;
      document.body.removeChild(tempDiv);
      
      // Minimum yükseklik: başlık + padding + border
      // Başlığın tam görünmesi için yeterli alan
      const minHeight = Math.max(60, textHeight + 32);
      card.style.height = minHeight + 'px';
      
      // Font boyutunu ayarla
      card.style.setProperty('--title-font-size', fontSize + 'px');
      
      card.classList.add('compact');
    } else {
      // Normal modda: Başlık için minimum yükseklik kontrolü
      const fontSize = Math.max(20, 20 + (boardZoom - 0.3) * 11.5);
      
      // Başlığın tam görünmesi için gereken yüksekliği hesapla
      const tempDiv = document.createElement('div');
      tempDiv.style.visibility = 'hidden';
      tempDiv.style.position = 'absolute';
      tempDiv.style.width = (noteWidth - 24) + 'px';
      tempDiv.style.fontSize = fontSize + 'px';
      tempDiv.style.fontWeight = '600';
      tempDiv.style.lineHeight = '1.4';
      tempDiv.style.wordWrap = 'break-word';
      tempDiv.style.overflowWrap = 'break-word';
      tempDiv.style.whiteSpace = 'normal';
      tempDiv.textContent = note.title;
      
      document.body.appendChild(tempDiv);
      const titleHeight = tempDiv.offsetHeight;
      document.body.removeChild(tempDiv);
      
      // Minimum yükseklik: başlık + header padding + body minimum
      const minRequiredHeight = titleHeight + 40 + 120; // header + body space
      const finalHeight = Math.max(noteHeight, minRequiredHeight);
      
      card.style.height = finalHeight + 'px';
      card.style.setProperty('--title-font-size', fontSize + 'px');
      
      card.classList.remove('compact');
    }
    
    card.innerHTML = `
      <div class="head">
        <div class="title">${highlightText(note.title, searchQuery)}</div>
        <div class="tools">
          <div class="mini" onclick="editNote('${note.id}')">✏️</div>
          <div class="mini" onclick="deleteNote('${note.id}')">🗑️</div>
        </div>
      </div>
      <div class="body">
        ${!isCompact ? `<div class="snippet">${renderedContent}</div>` : ''}
      </div>
      <div class="tags">
        ${!isCompact ? note.tags.slice(0, 4).map(tag => `<span class="tagtok">#${tag}</span>`).join('') : ''}
      </div>
      <div class="resize"></div>
    `;
    
    // Sağ tık menüsü ekle
    card.oncontextmenu = (e) => showContextMenu(e, note.id);
    
    // Drag ve resize işlevlerini ekle
    makeDraggable(card, note.id);
    makeResizable(card, note.id);
    
    board.appendChild(card);
  });
  
  // Klasör-not bağlantılarını çiz
  drawFolderConnections();
  
  // Bağlantıları çiz
  drawConnections();
  
  // Board boyutunu güncelle
  updateBoardSize();
  
  // Minimap'i güncelle
  renderGraph();
  
  // Not listesini güncelle
  renderNoteList();
  
  // Checkbox event listener'larını ekle
  document.querySelectorAll('.checklist-checkbox').forEach(checkbox => {
    checkbox.onclick = (e) => {
      e.stopPropagation(); // Not açılmasını engelle
      
      // Hangi nota ait olduğunu bul
      const noteElement = checkbox.closest('.note');
      if (!noteElement) return;
      
      const noteId = noteElement.id.replace('note-', '');
      const note = notes.find(n => n.id === noteId);
      if (!note) return;
      
      // Checkbox'ın metnini bul
      const checkboxText = checkbox.nextElementSibling.textContent;
      
      // Not metninde bu checkbox'ı bul ve güncelle
      let newText = note.text;
      if (checkbox.checked) {
        // Boş checkbox'ı işaretli yap
        newText = newText.replace(
          new RegExp(`^(\\s*)-\\s*\\[\\s*\\]\\s*${escapeRegex(checkboxText)}`, 'm'),
          '$1- [x] ' + checkboxText
        );
      } else {
        // İşaretli checkbox'ı boş yap
        newText = newText.replace(
          new RegExp(`^(\\s*)-\\s*\\[x\\]\\s*${escapeRegex(checkboxText)}`, 'mi'),
          '$1- [ ] ' + checkboxText
        );
      }
      
      // Notu güncelle
      updateNote(noteId, note.title, newText);
    };
  });
}

// Regex escape fonksiyonu
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Global resize state
let currentResizingElement = null;
let currentResizingNoteId = null;
let resizeStartX = 0;
let resizeStartY = 0;
let resizeStartWidth = 0;
let resizeStartHeight = 0;

// Global resize event listeners (sadece bir kez eklenir)
let resizeListenersAdded = false;

function addGlobalResizeListeners() {
  if (resizeListenersAdded) return;
  
  document.addEventListener('mousemove', (e) => {
    if (!currentResizingElement) return;
    
    e.preventDefault();
    
    const deltaX = e.clientX - resizeStartX;
    const deltaY = e.clientY - resizeStartY;
    
    const newWidth = Math.max(200, resizeStartWidth + deltaX);
    const newHeight = Math.max(180, resizeStartHeight + deltaY);
    
    currentResizingElement.style.width = newWidth + 'px';
    currentResizingElement.style.height = newHeight + 'px';
    
    // Not verisini güncelle
    const note = notes.find(n => n.id === currentResizingNoteId);
    if (note) {
      note.customWidth = newWidth;
      note.customHeight = newHeight;
    }
  });
  
  document.addEventListener('mouseup', (e) => {
    if (!currentResizingElement) return;
    
    currentResizingElement.classList.remove('resizing');
    document.body.style.cursor = 'default';
    
    // Pozisyonu kaydet
    saveNotes();
    
    // Bağlantıları güncelle
    drawConnections();
    renderGraph();
    
    // Reset resize state
    currentResizingElement = null;
    currentResizingNoteId = null;
  });
  
  resizeListenersAdded = true;
}

// Resize fonksiyonu
function makeResizable(element, noteId) {
  const resizeHandle = element.querySelector('.resize');
  if (!resizeHandle) return;
  
  // Global listeners'ı ekle (sadece ilk kez)
  addGlobalResizeListeners();
  
  resizeHandle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    currentResizingElement = element;
    currentResizingNoteId = noteId;
    resizeStartX = e.clientX;
    resizeStartY = e.clientY;
    resizeStartWidth = element.offsetWidth;
    resizeStartHeight = element.offsetHeight;
    
    element.classList.add('resizing');
    document.body.style.cursor = 'nwse-resize';
  });
}

// Drag & drop fonksiyonu
function makeDraggable(element, noteId) {
  let mouseDownTime = 0;
  let startX = 0;
  let startY = 0;
  let hasMoved = false;

  element.addEventListener('mousedown', dragStart);

  function dragStart(e) {
    // Sadece sol tık için drag başlat (sağ tık context menu için)
    if (e.button !== 0) {
      return;
    }
    
    if (e.target.classList.contains('mini') || e.target.classList.contains('resize') || e.target.classList.contains('checklist-checkbox')) {
      return;
    }
    
    if (e.target === element || element.contains(e.target)) {
      mouseDownTime = Date.now();
      startX = e.clientX;
      startY = e.clientY;
      hasMoved = false;

      // Mouse koordinatlarını canvas koordinatlarına çevir
      const board = document.getElementById('board');
      const boardRect = board.getBoundingClientRect();
      
      const boardStartX = e.clientX - boardRect.left;
      const boardStartY = e.clientY - boardRect.top;
      
      const note = notes.find(n => n.id === noteId);
      if (note) {
        // Eğer bu not seçiliyse, tüm seçili notlar için başlangıç pozisyonları kaydet
        if (selectedNotes.includes(noteId)) {
          // Multi-selection drag başlat
          selectedNotes.forEach(selectedId => {
            const selectedNote = notes.find(n => n.id === selectedId);
            const selectedElement = document.getElementById(`note-${selectedId}`);
            if (selectedNote && selectedElement) {
              selectedElement.dataset.dragStartX = boardStartX;
              selectedElement.dataset.dragStartY = boardStartY;
              selectedElement.dataset.initialNoteX = selectedNote.x || 0;
              selectedElement.dataset.initialNoteY = selectedNote.y || 0;
              selectedElement.dataset.clickStartX = startX;
              selectedElement.dataset.clickStartY = startY;
              selectedElement.dataset.mouseDownTime = mouseDownTime;
            }
          });
        } else {
          // Tek not drag başlat
          element.dataset.dragStartX = boardStartX;
          element.dataset.dragStartY = boardStartY;
        element.dataset.initialNoteX = note.x || 0;
        element.dataset.initialNoteY = note.y || 0;
          element.dataset.clickStartX = startX;
          element.dataset.clickStartY = startY;
          element.dataset.mouseDownTime = mouseDownTime;
        }
      }
      
      e.preventDefault();
    }
  }
  
  // Board render bittikten sonra minimap'i güncelle
  renderGraph();
}

// Gelişmiş bağlantı analizi
function analyzeConnections() {
  // Her not için bağlantı sayısını hesapla
  notes.forEach(note => {
    note.connectionCount = note.links.length;
    note.incomingCount = notes.filter(n => n.links.includes(note.title)).length;
    note.totalConnections = note.connectionCount + note.incomingCount;
  });
  
  // Hub notları belirle (en çok bağlantıya sahip %20)
  const sortedByConnections = [...notes].sort((a, b) => b.totalConnections - a.totalConnections);
  const hubThreshold = Math.ceil(notes.length * 0.2);
  const hubNotes = sortedByConnections.slice(0, hubThreshold);
  
  // Orphan notları belirle (hiç bağlantısı olmayan)
  const orphanNotes = notes.filter(note => note.totalConnections === 0);
  
  return { hubNotes, orphanNotes };
}

// Bağlantı türünü belirle
function getConnectionType(sourceNote, targetNote) {
  const isBidirectional = sourceNote.links.includes(targetNote.title) && 
                          targetNote.links.includes(sourceNote.title);
  
  const connectionStrength = isBidirectional ? 'strong' : 
                           (sourceNote.links.includes(targetNote.title) ? 'normal' : 'weak');
  
  return { isBidirectional, connectionStrength };
}

// Klasörleri board üzerinde render et
function renderFoldersOnBoard() {
  const board = document.getElementById('board');
  
  folders.forEach((folder, index) => {
    const folderNotes = notes.filter(note => note.folderId === folder.id);
    
    // Klasör pozisyonunu hesapla
    let x, y;
    if (folder.x !== undefined && folder.y !== undefined) {
      x = folder.x;
      y = folder.y;
    } else {
      // Grid düzeninde üst kısmına yerleştir
      const cols = Math.ceil(Math.sqrt(folders.length));
      const row = Math.floor(index / cols);
      const col = index % cols;
      x = 50 + col * 220; 
      y = 50 + row * 150;
      folder.x = x;
      folder.y = y;
    }
    
    // Klasör kartını oluştur
    const folderElement = document.createElement('div');
    const isCompact = boardZoom < 0.3; // Notlarla aynı threshold
    folderElement.className = `folder-card ${selectedFolder === folder.id ? 'selected' : ''} ${isCompact ? 'compact' : ''}`;
    folderElement.id = `folder-${folder.id}`;
    folderElement.style.left = x + 'px';
    folderElement.style.top = y + 'px';
    
    // Font boyutunu dinamik olarak ayarla (notlarla aynı mantık)
    let fontSize;
    if (isCompact) {
      // Compact modda: Zoom 0.1'de 50px, Zoom 0.3'te 30px
      fontSize = Math.max(30, 30 + (0.3 - boardZoom) * 400);
    } else {
      // Normal modda: Zoom artıkça büyür
      fontSize = Math.max(20, 20 + (boardZoom - 0.3) * 11.5);
    }
    folderElement.style.setProperty('--title-font-size', fontSize + 'px');
    
    folderElement.innerHTML = `
      <div class="folder-header">
        <div class="folder-title">${folder.name}</div>
        <div class="folder-note-count">${folderNotes.length}</div>
      </div>
      <div class="folder-color-indicator" style="background: ${folder.color};"></div>
    `;
    
    // Klasör tıklama olayı global event handler'da yapılacak
    
    // Sağ tık menüsü ekle
    folderElement.oncontextmenu = (e) => showFolderContextMenu(e, folder.id);
    
    // Klasör event'leri global sistemde handle edilecek
    
    board.appendChild(folderElement);
  });
}

// Klasör-not bağlantılarını çiz
function drawFolderConnections() {
  // Önceki klasör bağlantı çizgilerini temizle
  const existingFolderLines = document.querySelectorAll('.folder-connection-line');
  existingFolderLines.forEach(line => line.remove());
  
  const board = document.getElementById('board');
  
  folders.forEach(folder => {
    const folderElement = document.getElementById(`folder-${folder.id}`);
    if (!folderElement) return;
    
    const folderNotes = notes.filter(note => note.folderId === folder.id);
    
    folderNotes.forEach(note => {
      const noteElement = document.getElementById(`note-${note.id}`);
      if (!noteElement) return;
      
      // Klasör ve not boyutlarını al
      const folderWidth = 200;
      const folderHeight = 100;
      const noteWidth = parseFloat(noteElement.style.width) || note.customWidth || 280;
      const noteHeight = parseFloat(noteElement.style.height) || note.customHeight || 120;
      
      // Koordinatları hesapla (not bağlantıları ile aynı mantık)
      const folderX = folder.x + folderWidth / 2;     // Klasör merkezi
      const folderY = folder.y + folderHeight;        // Klasör alt kenarı
      const noteX = note.x + noteWidth / 2;           // Not merkezi X
      const noteY = note.y + noteHeight / 2;          // Not merkezi Y
      
      // Mesafe ve açı hesapla
      const deltaX = noteX - folderX;
      const deltaY = noteY - folderY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      
      // Bağlantı çizgisi oluştur
      const line = document.createElement('div');
      line.className = 'folder-connection-line';
      line.style.left = folderX + 'px';
      line.style.top = folderY + 'px';
      line.style.width = distance + 'px';
      line.style.transform = `rotate(${angle}deg)`;
      line.style.background = folder.color;
      
      board.appendChild(line);
    });
  });
}


// Bağlantıları çiz - Gelişmiş sistem
function drawConnections() {
  // Önceki bağlantı çizgilerini ve etiketleri temizle
  const existingLines = document.querySelectorAll('.connection-line, .connection-label');
  existingLines.forEach(line => line.remove());
  
  const { hubNotes, orphanNotes } = analyzeConnections();
  
  // Tüm notlar arası bağlantıları çiz
  notes.forEach(note => {
    if (!note.x || !note.y) return; // Pozisyon yoksa çizme
    
    note.links.forEach(linkTitle => {
      const targetNote = notes.find(n => n.title === linkTitle);
      if (!targetNote || !targetNote.x || !targetNote.y) return;
      
      // Bağlantı çizgisi oluştur
      createConnectionLine(note, targetNote, hubNotes, orphanNotes);
    });
  });
  
  // Not stillerini güncelle
  updateNoteStyles(hubNotes, orphanNotes);
}

// Not stillerini güncelle
function updateNoteStyles(hubNotes, orphanNotes) {
  notes.forEach(note => {
    const element = document.getElementById(`note-${note.id}`);
    if (!element) return;
    
    // Önceki stilleri temizle
    element.classList.remove('hub', 'orphan');
    
    // Hub not mu?
    if (graphSettings.showHubs && hubNotes.some(hub => hub.id === note.id)) {
      element.classList.add('hub');
    }
    
    // Orphan not mu?
    if (graphSettings.showOrphans && orphanNotes.some(orphan => orphan.id === note.id)) {
      element.classList.add('orphan');
    }
  });
}

// Bağlantı çizgisi oluştur - Gelişmiş
function createConnectionLine(sourceNote, targetNote, hubNotes, orphanNotes) {
  const board = document.getElementById('board');
  
  // DOM elementlerini al
  const sourceElement = document.getElementById(`note-${sourceNote.id}`);
  const targetElement = document.getElementById(`note-${targetNote.id}`);
  
  if (!sourceElement || !targetElement) return;
  
  // Gerçek element boyutlarını al (CSS ile ayarlanmış boyutlar)
  const sourceWidth = parseFloat(sourceElement.style.width) || sourceNote.customWidth || 280;
  const sourceHeight = parseFloat(sourceElement.style.height) || sourceNote.customHeight || getNoteHeight(sourceNote);
  const targetWidth = parseFloat(targetElement.style.width) || targetNote.customWidth || 280;
  const targetHeight = parseFloat(targetElement.style.height) || targetNote.customHeight || getNoteHeight(targetNote);
  
  // Board koordinat sisteminde merkez koordinatlarını hesapla
  const sourceX = sourceNote.x + sourceWidth / 2;
  const sourceY = sourceNote.y + sourceHeight / 2;
  const targetX = targetNote.x + targetWidth / 2;
  const targetY = targetNote.y + targetHeight / 2;
  
  // Mesafe ve açı hesapla
  const deltaX = targetX - sourceX;
  const deltaY = targetY - sourceY;
  const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
  
  // Bağlantı türünü belirle
  const { isBidirectional, connectionStrength } = getConnectionType(sourceNote, targetNote);
  
  // Bağlantı çizgisi elementi oluştur
  const line = document.createElement('div');
  line.className = `connection-line ${isBidirectional ? 'bidirectional' : ''} ${connectionStrength}`;
  line.style.left = sourceX + 'px';
  line.style.top = sourceY + 'px';
  line.style.width = distance + 'px';
  line.style.transform = `rotate(${angle}deg)`;
  
  // Bağlantı etiketi ekle (çift yönlü bağlantılar için)
  if (isBidirectional && distance > 100) {
    const label = document.createElement('div');
    label.className = 'connection-label';
    label.textContent = '↔';
    label.style.left = (sourceX + deltaX / 2 - 10) + 'px';
    label.style.top = (sourceY + deltaY / 2 - 10) + 'px';
    board.appendChild(label);
  }
  
  board.appendChild(line);
}

// Not düzenleme fonksiyonu
// Basit Etiket Sistemi
let activeTagFilters = [];
let tagSearchQuery = '';

// Etiket kartlarını render et
function renderTagCards() {
  const cardsContainer = document.getElementById('tagCards');
  if (!cardsContainer) return;
  
  // Etiket istatistiklerini topla
  const tagStats = {};
  notes.forEach(note => {
    note.tags.forEach(tag => {
      if (!tagStats[tag]) {
        tagStats[tag] = {
          count: 0,
          notes: [],
          lastUsed: new Date(note.updatedAt)
        };
      }
      tagStats[tag].count++;
      tagStats[tag].notes.push(note);
      if (new Date(note.updatedAt) > tagStats[tag].lastUsed) {
        tagStats[tag].lastUsed = new Date(note.updatedAt);
      }
    });
  });
  
  // Etiketleri filtrele ve sırala
  let tags = Object.entries(tagStats)
    .filter(([tag]) => !tagSearchQuery || tag.toLowerCase().includes(tagSearchQuery.toLowerCase()))
    .sort(([,a], [,b]) => b.count - a.count); // En çok kullanılan ilk önce
  
  // Kartları oluştur
  cardsContainer.innerHTML = tags.map(([tag, stats]) => {
    const isActive = activeTagFilters.includes(tag);
    const daysSinceLastUse = Math.floor((new Date() - stats.lastUsed) / (1000 * 60 * 60 * 24));
    const noteTitles = stats.notes.slice(0, 3).map(note => note.title).join(', ');
    
    return `
      <div class="tag-card ${isActive ? 'active' : ''}" data-tag="${tag}">
        <div class="tag-card-header">
          <div class="tag-card-name">#${tag}</div>
          <div class="tag-card-count">${stats.count}</div>
        </div>
        <div class="tag-card-stats">
          <div class="tag-stat">Son: <span class="tag-stat-value">${daysSinceLastUse === 0 ? 'Bugün' : daysSinceLastUse + ' gün'}</span></div>
          <div class="tag-stat">Not: <span class="tag-stat-value">${stats.count}</span></div>
        </div>
        <div class="tag-card-preview">${noteTitles || 'Notlar...'}</div>
      </div>
    `;
  }).join('');
  
  // Click event'leri ekle
  cardsContainer.querySelectorAll('.tag-card').forEach(card => {
    card.onclick = () => {
      const tag = card.dataset.tag;
      toggleTagFilter(tag);
    };
  });
  
  // Aktif filtreleri render et
  renderActiveTagFilters();
}

// Etiket filtresi toggle
function toggleTagFilter(tag) {
  if (activeTagFilters.includes(tag)) {
    activeTagFilters = activeTagFilters.filter(t => t !== tag);
  } else {
    activeTagFilters.push(tag);
  }
  
  renderTagCards();
  renderNotes();
  renderNoteList();
}

// Aktif filtreleri render et
function renderActiveTagFilters() {
  const filtersContainer = document.getElementById('activeFilters');
  
  if (activeTagFilters.length === 0) {
    filtersContainer.innerHTML = '';
    return;
  }
  
  filtersContainer.innerHTML = activeTagFilters.map(tag => `
    <div class="filter-chip">
      <span>#${tag}</span>
      <span class="filter-chip-remove" onclick="removeTagFilter('${tag}')">✕</span>
    </div>
  `).join('');
}

// Filtre kaldır
function removeTagFilter(tag) {
  activeTagFilters = activeTagFilters.filter(t => t !== tag);
  renderTagCards();
  renderNotes();
  renderNoteList();
}

// Arama temizle
function clearTagSearch() {
  tagSearchQuery = '';
  document.getElementById('tagSearch').value = '';
  renderTagCards();
}

// Minimap/Graph render et
function renderGraph() {
  const minimap = document.getElementById('minimap');
  if (!minimap) return;
  
  const viewport = minimap.querySelector('.minimap-viewport');
  if (!viewport) return;
  
  
  // Önce temizle
  viewport.innerHTML = '';
  
  // İçerik yoksa kontrol et
  if (notes.length === 0 && folders.length === 0) {
    viewport.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px;">Henüz içerik yok</div>';
    return;
  }

  // Board boyutlarını hesapla
  const board = document.getElementById('board');
  const boardRect = board.getBoundingClientRect();
  
  // Notların ve klasörlerin gerçek pozisyonlarını kullanarak board sınırlarını bul
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  notes.forEach(note => {
    if (note.x !== undefined && note.y !== undefined) {
      minX = Math.min(minX, note.x);
      minY = Math.min(minY, note.y);
      
      // Not boyutlarını hesapla
      let noteWidth = 280;
      let noteHeight = 120;
      
      if (note.customWidth) {
        noteWidth = note.customWidth;
      }
      if (note.customHeight) {
        noteHeight = note.customHeight;
      }
      
      maxX = Math.max(maxX, note.x + noteWidth);
      maxY = Math.max(maxY, note.y + noteHeight);
    }
  });
  
  // Klasörleri de dahil et
  folders.forEach(folder => {
    if (folder.x !== undefined && folder.y !== undefined) {
      minX = Math.min(minX, folder.x);
      minY = Math.min(minY, folder.y);
      maxX = Math.max(maxX, folder.x + 200); // klasör genişliği
      maxY = Math.max(maxY, folder.y + 100); // klasör yüksekliği
    }
  });
  
  // Eğer hiç not yoksa varsayılan değerler
  if (minX === Infinity) {
    minX = 0; minY = 0; maxX = 800; maxY = 600;
  }
  
  // Board boyutları
  const boardWidth = maxX - minX;
  const boardHeight = maxY - minY;
  
  // Minimap boyutları (dinamik olarak ayarla)
  const minimapWidth = minimap.offsetWidth || 300;
  const minimapHeight = minimap.offsetHeight || 200;
  
  // Ölçekleme faktörü (padding ile)
  const padding = 20;
  const scaleX = (minimapWidth - padding * 2) / boardWidth;
  const scaleY = (minimapHeight - padding * 2) / boardHeight;
  const scale = Math.min(scaleX, scaleY, 1); // 1'den büyük olmasın
  
  // Viewport boyutlarını ayarla
  viewport.style.width = minimapWidth + 'px';
  viewport.style.height = minimapHeight + 'px';
  viewport.style.position = 'relative';
  viewport.style.background = 'var(--elev)';
  viewport.style.border = '1px solid var(--border)';
  viewport.style.borderRadius = '8px';
  viewport.style.overflow = 'hidden';
  
  // Zoom göstergesi ekle
  const zoomIndicator = document.createElement('div');
  zoomIndicator.className = 'minimap-zoom-indicator';
  zoomIndicator.style.position = 'absolute';
  zoomIndicator.style.top = '5px';
  zoomIndicator.style.right = '5px';
  zoomIndicator.style.background = 'var(--accent)';
  zoomIndicator.style.color = 'white';
  zoomIndicator.style.padding = '2px 6px';
  zoomIndicator.style.borderRadius = '4px';
  zoomIndicator.style.fontSize = '10px';
  zoomIndicator.style.fontWeight = 'bold';
  zoomIndicator.style.zIndex = '10';
  zoomIndicator.textContent = `${Math.round(boardZoom * 100)}%`;
  viewport.appendChild(zoomIndicator);
  
  // Hub ve orphan notları analiz et
  const { hubNotes, orphanNotes } = analyzeConnections();
  
  // Klasörleri render et
  folders.forEach(folder => {
    if (folder.x === undefined || folder.y === undefined) return;
    
    const folderElement = document.createElement('div');
    folderElement.className = 'minimap-folder';
    folderElement.style.position = 'absolute';
    folderElement.style.left = padding + (folder.x - minX) * scale + 'px';
    folderElement.style.top = padding + (folder.y - minY) * scale + 'px';
    folderElement.style.width = (200 * scale) + 'px';
    folderElement.style.height = (100 * scale) + 'px';
    folderElement.style.background = folder.color;
    folderElement.style.border = '1px solid ' + folder.color;
    folderElement.style.borderRadius = '6px';
    folderElement.style.opacity = '0.7';
    folderElement.style.cursor = 'pointer';
    
    // Klasör tıklama
    folderElement.onclick = () => {
      selectFolder(folder.id);
      centerOnFolder(folder.id);
    };
    
    viewport.appendChild(folderElement);
  });
  
  // Notları render et
  notes.forEach(note => {
    if (note.x === undefined || note.y === undefined) return;
    
    const noteElement = document.createElement('div');
    noteElement.className = 'minimap-note';
    noteElement.style.position = 'absolute';
    noteElement.style.left = padding + (note.x - minX) * scale + 'px';
    noteElement.style.top = padding + (note.y - minY) * scale + 'px';
    // Yuvarlak boyutunu hesapla (küçük ama görünür olsun)
    const circleSize = Math.max(8, 12 * scale);
    noteElement.style.width = circleSize + 'px';
    noteElement.style.height = circleSize + 'px';
    
    // Not rengini belirle - klasörü varsa klasör rengi, yoksa varsayılan
    let noteColor = 'var(--panel)'; // Varsayılan renk
    if (note.folderId) {
      const noteFolder = folders.find(f => f.id === note.folderId);
      if (noteFolder && noteFolder.color) {
        noteColor = noteFolder.color;
      }
    } else {
      // Klasörü olmayan notlar için özel renk
      noteColor = '#6b7280'; // Gri ton
    }
    
    // Seçili not için accent rengi kullan
    noteElement.style.background = note.id === selectedNote ? 'var(--accent)' : noteColor;
    noteElement.style.border = '1px solid var(--border)';
    noteElement.style.borderRadius = '50%'; // Tam yuvarlak yapar
    noteElement.style.cursor = 'pointer';
    noteElement.dataset.noteId = note.id;
    noteElement.title = note.title; // Hover'da başlığı göster
    
    // Seçili not mu kontrol et
    if (note.id === selectedNote) {
      noteElement.classList.add('selected');
      noteElement.style.border = '2px solid var(--accent)';
    }
    
    // Hub not mu kontrol et
    if (hubNotes.some(hub => hub.id === note.id)) {
      noteElement.classList.add('hub');
      noteElement.style.border = '2px solid var(--warning)';
      noteElement.style.boxShadow = '0 0 4px var(--warning)';
    }
    
    // Orphan not mu kontrol et
    if (orphanNotes.some(orphan => orphan.id === note.id)) {
      noteElement.classList.add('orphan');
      noteElement.style.opacity = '0.5';
    }
    
    // Bağlı not mu kontrol et (seçili nota bağlı olanlar)
    const isConnected = selectedNote && selectedNote !== note.id && (
      note.links.includes(notes.find(n => n.id === selectedNote)?.title || '') ||
      notes.find(n => n.id === selectedNote)?.links.includes(note.title)
    );
    
    if (isConnected) {
      noteElement.classList.add('connected');
      noteElement.style.border = '2px solid var(--success)';
    }
    
    // Not tıklama
    noteElement.onclick = () => {
      selectNote(note.id);
      centerOnNote(note.id);
    };
    
    viewport.appendChild(noteElement);
  });
  
  // Klasör-not bağlantılarını render et
  folders.forEach(folder => {
    const folderNotes = notes.filter(note => note.folderId === folder.id);
    
    folderNotes.forEach(note => {
      if (folder.x === undefined || folder.y === undefined || 
          note.x === undefined || note.y === undefined) return;
      
      const folderX = padding + (folder.x - minX) * scale + (200 * scale) / 2;
      const folderY = padding + (folder.y - minY) * scale + (100 * scale) / 2;
      const circleSize = Math.max(8, 12 * scale);
      const noteX = padding + (note.x - minX) * scale + circleSize / 2;
      const noteY = padding + (note.y - minY) * scale + circleSize / 2;
      
      const deltaX = noteX - folderX;
      const deltaY = noteY - folderY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      
      const connection = document.createElement('div');
      connection.className = 'minimap-connection folder-connection';
      connection.style.position = 'absolute';
      connection.style.left = folderX + 'px';
      connection.style.top = folderY + 'px';
      connection.style.width = distance + 'px';
      connection.style.height = '1px';
      connection.style.background = folder.color;
      connection.style.transformOrigin = 'left center';
      connection.style.transform = `rotate(${angle}deg)`;
      connection.style.opacity = '0.5';
      connection.style.zIndex = '0';
      
      viewport.appendChild(connection);
    });
  });
  
  // Not-not bağlantılarını render et
  notes.forEach(note => {
    if (!note.links || note.x === undefined || note.y === undefined) return;
    
    note.links.forEach(linkTitle => {
      const targetNote = notes.find(n => n.title === linkTitle);
      if (!targetNote || targetNote.x === undefined || targetNote.y === undefined) return;
      
      const circleSize = Math.max(8, 12 * scale);
      const sourceX = padding + (note.x - minX) * scale + circleSize / 2;
      const sourceY = padding + (note.y - minY) * scale + circleSize / 2;
      const targetX = padding + (targetNote.x - minX) * scale + circleSize / 2;
      const targetY = padding + (targetNote.y - minY) * scale + circleSize / 2;
      
      const deltaX = targetX - sourceX;
      const deltaY = targetY - sourceY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      
      const connection = document.createElement('div');
      connection.className = 'minimap-connection note-connection';
      connection.style.position = 'absolute';
      connection.style.left = sourceX + 'px';
      connection.style.top = sourceY + 'px';
      connection.style.width = distance + 'px';
      connection.style.height = '1px';
      connection.style.background = 'var(--accent)';
      connection.style.transformOrigin = 'left center';
      connection.style.transform = `rotate(${angle}deg)`;
      connection.style.opacity = '0.4';
      connection.style.zIndex = '1';
      
      viewport.appendChild(connection);
    });
  });
}

// Klasöre odaklan
function centerOnFolder(folderId) {
  const folder = folders.find(f => f.id === folderId);
  if (!folder || folder.x === undefined || folder.y === undefined) return;
  
  const boardwrap = document.querySelector('.boardwrap');
  if (!boardwrap) return;
  
  const boardwrapRect = boardwrap.getBoundingClientRect();
  
  // Klasörün boyutları (200x100)
  const folderWidth = 200;
  const folderHeight = 100;
  
  // Klasörün merkez koordinatları (stored x,y + half size)
  const folderCenterX = folder.x + folderWidth / 2;
  const folderCenterY = folder.y + folderHeight / 2;
  
  // Boardwrap'in merkez koordinatları
  const viewportCenterX = boardwrapRect.width / 2;
  const viewportCenterY = boardwrapRect.height / 2;
  
  // Pan değerlerini hesapla (klasörün merkezini viewport merkezine getir)
  boardPanX = viewportCenterX - (folderCenterX * boardZoom);
  boardPanY = viewportCenterY - (folderCenterY * boardZoom);
  
  updateBoardTransform();
}

// Nota odaklan (eski versiyon silindi - üstteki gelişmiş versiyon kullanılıyor)

// Etiket arama
function searchTags(query) {
  tagSearchQuery = query;
  renderTagCards();
}

// Ana render fonksiyonu
function renderTags() {
  renderTagCards();
}


// Not listesini render et
function renderNoteList() {
  const notelistContainer = document.getElementById('notelist');
  if (!notelistContainer) return;
  
  // Önceki içeriği temizle
  notelistContainer.innerHTML = '';
  
  if (notes.length === 0) {
    notelistContainer.innerHTML = '<div style="text-align: center; color: var(--muted); padding: 20px; font-size: 12px;">Henüz not yok</div>';
    return;
  }
  
  // Notları tarihe göre sırala (en yeni önce)
  const sortedNotes = [...notes].sort((a, b) => {
    return new Date(b.updatedAt) - new Date(a.updatedAt);
  });
  
  // Filtreleme uygula
  const filteredNotes = sortedNotes.filter(note => {
    const matchesSearch = !searchQuery || 
      note.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      note.text.toLowerCase().includes(searchQuery.toLowerCase()) ||
      note.tags.some(tag => tag.includes(searchQuery.toLowerCase()));
    
    // Aktif etiket filtreleri kontrolü (tüm seçili etiketler notda bulunmalı)
    const matchesTagFilters = activeTagFilters.length === 0 || 
      activeTagFilters.every(filter => note.tags.includes(filter));
    
    return matchesSearch && matchesTagFilters;
  });
  
  // Not listesi oluştur
  filteredNotes.forEach(note => {
    const item = document.createElement('div');
    item.className = `notelist-item ${note.id === selectedNote ? 'selected' : ''}`;
    item.dataset.noteId = note.id;
    
    // Tarih formatını ayarla
    const date = new Date(note.updatedAt);
    const dateStr = date.toLocaleDateString('tr-TR', {
      day: '2-digit',
      month: '2-digit',
      year: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    // İçerik snippet'i oluştur
    const snippet = note.text.substring(0, 80) + (note.text.length > 80 ? '...' : '');
    
    item.innerHTML = `
      <div class="title">${highlightText(note.title, searchQuery)}</div>
      <div class="snippet">${highlightText(snippet, searchQuery)}</div>
      <div class="meta">
        <div class="tags">
          ${note.tags.slice(0, 3).map(tag => `<span class="tag">#${tag}</span>`).join('')}
        </div>
        <div class="date">${dateStr}</div>
      </div>
    `;
    
    // Tıklama eventi
    item.onclick = () => {
      selectNote(note.id);
      centerOnNote(note.id);
    };
    
    notelistContainer.appendChild(item);
  });
  
}

// Klasör listesini render et
function renderFolderList() {
  const folderListContainer = document.getElementById('folderList');
  if (!folderListContainer) return;
  
  // Önceki içeriği temizle
  folderListContainer.innerHTML = '';
  
  // Tüm notları göster seçeneği
  const allItem = document.createElement('div');
  allItem.className = `folder-item ${selectedFolder === null ? 'active' : ''}`;
  allItem.innerHTML = `
    <div class="folder-color" style="background: var(--accent);"></div>
    <div class="folder-name">Tüm Notlar</div>
    <div class="folder-count">${notes.length}</div>
  `;
  allItem.onclick = () => {
    selectFolder(null);
    toggleAllFolders();
  };
  folderListContainer.appendChild(allItem);
  
  // Klasörsüz notlar
  const orphanNotes = notes.filter(note => !note.folderId);
  if (orphanNotes.length > 0) {
    const isOrphanExpanded = expandedFolders.includes('orphan');
    
    const orphanItem = document.createElement('div');
    orphanItem.className = `folder-item ${selectedFolder === 'orphan' ? 'active' : ''}`;
    orphanItem.innerHTML = `
      <div style="display: flex; align-items: center; width: 100%;">
        <div style="width: 12px; height: 12px; margin-right: 4px; color: var(--muted); font-size: 10px; text-align: center;">
          ${isOrphanExpanded ? '▼' : '▶'}
        </div>
        <div class="folder-color" style="background: var(--muted);"></div>
        <div class="folder-name" style="flex: 1;">Klasörsüz Notlar</div>
        <div class="folder-count">${orphanNotes.length}</div>
      </div>
    `;
    orphanItem.onclick = () => {
      selectFolder('orphan');
      toggleFolder('orphan');
    };
    makeFolderDroppable(orphanItem, null); // null = klasörsüz yap
    folderListContainer.appendChild(orphanItem);
    
    // Klasörsüz notları göster (eğer açıksa)
    if (isOrphanExpanded) {
      orphanNotes.forEach(note => {
        const noteItem = document.createElement('div');
        noteItem.className = `note-item ${note.id === selectedNote ? 'selected' : ''}`;
        noteItem.innerHTML = `
          <div style="width: 8px; height: 8px; border-radius: 50%; background: var(--muted);"></div>
          <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${note.title}</div>
        `;
        noteItem.onclick = (e) => {
          e.stopPropagation();
          selectNote(note.id);
          centerOnNote(note.id);
        };
        noteItem.oncontextmenu = (e) => showContextMenu(e, note.id);
        makeNoteDraggable(noteItem, note.id);
        folderListContainer.appendChild(noteItem);
      });
    }
  }
  
     // Klasörler
   folders.forEach(folder => {
     const folderNotes = getFolderNotes(folder.id);
     const isExpanded = expandedFolders.includes(folder.id);
     
     const folderItem = document.createElement('div');
     folderItem.className = `folder-item ${selectedFolder === folder.id ? 'active' : ''}`;
     folderItem.innerHTML = `
       <div style="display: flex; align-items: center; width: 100%;">
         <div style="width: 12px; height: 12px; margin-right: 4px; color: var(--muted); font-size: 10px; text-align: center;">
           ${folderNotes.length > 0 ? (isExpanded ? '▼' : '▶') : '·'}
         </div>
         <div class="folder-color" style="background: ${folder.color};" onclick="event.stopPropagation(); changeFolderColor('${folder.id}');"></div>
         <div class="folder-name" style="flex: 1;">${folder.name}</div>
         <div class="folder-count">${folderNotes.length}</div>
         <div style="width: 16px; height: 16px; margin-left: 4px; cursor: pointer; color: var(--danger); font-size: 12px; text-align: center; opacity: 0.7;" onclick="event.stopPropagation(); deleteFolder('${folder.id}');" title="Klasörü Sil">
           🗑️
         </div>
       </div>
     `;
     folderItem.onclick = (e) => {
       // Eğer renk veya silme butonuna tıklanmadıysa
       if (!e.target.closest('.folder-color') && !e.target.closest('[title="Klasörü Sil"]')) {
         selectFolder(folder.id);
         toggleFolder(folder.id);
       }
     };
     makeFolderDroppable(folderItem, folder.id);
     folderListContainer.appendChild(folderItem);
     
     // Bu klasördeki notları göster (eğer açıksa)
     if (isExpanded && folderNotes.length > 0) {
       folderNotes.forEach(note => {
         const noteItem = document.createElement('div');
         noteItem.className = `note-item ${note.id === selectedNote ? 'selected' : ''}`;
         noteItem.innerHTML = `
           <div style="width: 8px; height: 8px; border-radius: 50%; background: ${folder.color};"></div>
           <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${note.title}</div>
         `;
         noteItem.onclick = (e) => {
           e.stopPropagation();
           selectNote(note.id);
           centerOnNote(note.id);
         };
         noteItem.oncontextmenu = (e) => showContextMenu(e, note.id);
         makeNoteDraggable(noteItem, note.id);
         folderListContainer.appendChild(noteItem);
       });
     }
   });

}

// Klasör rengi değiştir
function changeFolderColor(folderId) {
  const folder = folders.find(f => f.id === folderId);
  if (!folder) return;
  
  const currentIndex = FOLDER_COLORS.indexOf(folder.color);
  const nextIndex = (currentIndex + 1) % FOLDER_COLORS.length;
  folder.color = FOLDER_COLORS[nextIndex];
  
  saveFolders();
  renderFolderList();
  renderNotes(); // Kartların rengini güncelle
  
}

// Context menu fonksiyonları
function showContextMenu(e, noteId) {
  e.preventDefault();
  e.stopPropagation();
  
  // Mevcut context menu'yu kaldır
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  
  const note = notes.find(n => n.id === noteId);
  if (!note) return;
  
  // Taşınabilir klasörler
  menu.innerHTML = `
    <div class="context-menu-item" onclick="editNote('${noteId}')">
      ✏️ Düzenle
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="changeNoteFolder('${noteId}', null)">
      📄 Klasörsüz
    </div>
    ${folders.map(folder => 
      `<div class="context-menu-item ${note.folderId === folder.id ? 'selected' : ''}" onclick="changeNoteFolder('${noteId}', '${folder.id}')">
        <div style="width: 12px; height: 12px; border-radius: 50%; background: ${folder.color};"></div>
        ${folder.name}
      </div>`
    ).join('')}
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="deleteNote('${noteId}')">
      🗑️ Sil
    </div>
  `;
  
  document.body.appendChild(menu);
  
  // Dışarı tıklanınca kapat
  setTimeout(() => {
    document.addEventListener('click', hideContextMenu, { once: true });
  }, 100);
}

function hideContextMenu() {
  const existingMenu = document.querySelector('.context-menu');
  if (existingMenu) {
    existingMenu.remove();
  }
}

function showFolderContextMenu(e, folderId) {
  e.preventDefault();
  e.stopPropagation();
  
  // Mevcut context menu'yu kaldır
  hideContextMenu();
  
  const menu = document.createElement('div');
  menu.className = 'context-menu';
  menu.style.left = e.clientX + 'px';
  menu.style.top = e.clientY + 'px';
  
  const folder = folders.find(f => f.id === folderId);
  if (!folder) return;
  
  menu.innerHTML = `
    <div class="context-menu-item" onclick="changeFolderColor('${folderId}')">
      🎨 Renk Değiştir
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="deleteFolder('${folderId}')">
      🗑️ Klasörü Sil
    </div>
  `;
  
  document.body.appendChild(menu);
  
  // Dışarı tıklanınca kapat
  setTimeout(() => {
    document.addEventListener('click', hideContextMenu, { once: true });
  }, 100);
}

// Drag & Drop fonksiyonları
let draggedNoteId = null;

function makeFolderDroppable(folderElement, folderId) {
  folderElement.addEventListener('dragover', (e) => {
    e.preventDefault();
    folderElement.classList.add('drag-over');
  });
  
  folderElement.addEventListener('dragleave', (e) => {
    if (!folderElement.contains(e.relatedTarget)) {
      folderElement.classList.remove('drag-over');
    }
  });
  
  folderElement.addEventListener('drop', (e) => {
    e.preventDefault();
    folderElement.classList.remove('drag-over');
    
    if (draggedNoteId) {
      changeNoteFolder(draggedNoteId, folderId);
      draggedNoteId = null;
    }
  });
}

function makeNoteDraggable(noteElement, noteId) {
  noteElement.draggable = true;
  
  noteElement.addEventListener('dragstart', (e) => {
    draggedNoteId = noteId;
    noteElement.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  });
  
  noteElement.addEventListener('dragend', (e) => {
    noteElement.classList.remove('dragging');
    // Tüm drag-over sınıflarını temizle
    document.querySelectorAll('.drag-over').forEach(el => {
      el.classList.remove('drag-over');
    });
  });
}

function renderPreview() {
  const preview = document.getElementById('preview');
  const bodyInput = document.getElementById('bodyIn');
  
  if (!preview) {
    console.error('Preview elementi bulunamadı!');
    return;
  }
  
  if (!bodyInput) {
    console.error('Body input elementi bulunamadı!');
    return;
  }
  
  const text = bodyInput.value;
  
  preview.innerHTML = renderMarkdown(text);
  
  // Checkbox eventleri - Düzeltilmiş
  preview.querySelectorAll('.checklist-checkbox').forEach((checkbox) => {
    checkbox.onchange = () => {
      const lines = text.split('\n');
      const checklistItems = preview.querySelectorAll('.checklist-item');
      
      // Bu checkbox'ın kaçıncı sırada olduğunu bul
      let itemIndex = -1;
      for (let i = 0; i < checklistItems.length; i++) {
        if (checklistItems[i].querySelector('.checklist-checkbox') === checkbox) {
          itemIndex = i;
          break;
        }
      }
      
      if (itemIndex >= 0) {
        // Markdown metninde checklist satırını bul ve güncelle
        let checklistCount = 0;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.match(/^\s*-\s*\[( |x|X)\]\s*(.*)$/)) {
            if (checklistCount === itemIndex) {
              const isChecked = checkbox.checked;
              lines[i] = line.replace(/\[( |x|X)\]/, `[${isChecked ? 'x' : ' '}]`);
              break;
            }
            checklistCount++;
          }
        }
        
        // Metni güncelle
        bodyInput.value = lines.join('\n');
        
        // Notu kaydet
        updateNote(selectedNote, document.getElementById('titleIn').value, bodyInput.value);
      }
    };
  });
  
  // Wikilink eventleri
  preview.querySelectorAll('.wikilink').forEach(link => {
    link.onclick = () => {
      const linkText = link.dataset.link;
      let targetNote = notes.find(n => n.title === linkText);
      
      if (!targetNote) {
        // Yeni not oluştur
        targetNote = {
          id: generateId(),
          title: linkText,
          text: '',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          tags: [],
          links: []
        };
        notes.unshift(targetNote);
        saveNotes();
      }
      
      selectNote(targetNote.id);
      openZenMode(targetNote.id);
    };
  });
  
}

// Widget işlemleri
function openWidget() { 
    document.getElementById('widget').classList.add('open');
}

function closeWidget() { 
    document.getElementById('widget').classList.remove('open');
  closeDrawer();
}

// Zen Writing Mode İşlemleri
let zenCurrentNoteId = null;
let wikilinkAutocomplete = null;
let selectedAutocompleteIndex = -1;

function openZenMode(noteId = null) {
  const zenOverlay = document.getElementById('zenOverlay');
  const zenTitleInput = document.getElementById('zenTitleInput');
  const zenBodyInput = document.getElementById('zenBodyInput');
  
  if (zenOverlay && zenTitleInput && zenBodyInput) {
    // Doğrudan geçilen noteId'yi kullan, yoksa selectedNote'u kullan
    const targetNoteId = noteId || selectedNote;
    console.log('🎯 Target noteId:', targetNoteId);
    
    // Mevcut not varsa verilerini yükle
    if (targetNoteId) {
      zenCurrentNoteId = targetNoteId;
      const note = notes.find(n => n.id === targetNoteId);
      if (note) {
        
        zenTitleInput.value = note.title === 'Başlıksız Not' ? '' : note.title;
        zenBodyInput.value = note.text;
        
        // Stats'i hemen güncelle (önceki notun verileri kalmasın)
        updateZenStats();
        updateZenHighlight();
      }
    } else {
      zenCurrentNoteId = null;
      zenTitleInput.value = '';
      zenBodyInput.value = '';
      
      // Stats'i temizle
      updateZenStats();
      updateZenHighlight();
    }
    
    // Overlay'i göster
    zenOverlay.classList.add('active');
    
    // İlk input'a focus ver
    setTimeout(() => {
      if (zenTitleInput.value === '') {
        zenTitleInput.focus();
  } else {
        zenBodyInput.focus();
        zenBodyInput.setSelectionRange(zenBodyInput.value.length, zenBodyInput.value.length);
      }
      updateZenStats();
      updateZenHighlight();
    }, 600); // Animasyon bitimini bekle
    
  } else {
    console.error('Zen Mode elementleri bulunamadı!');
  }
}

function closeZenMode() {
  const zenOverlay = document.getElementById('zenOverlay');
  const zenTitleInput = document.getElementById('zenTitleInput');
  const zenBodyInput = document.getElementById('zenBodyInput');
  const zenHighlight = document.getElementById('zenHighlight');
  
  if (zenOverlay) {
    zenOverlay.classList.remove('active');
    zenCurrentNoteId = null;
    
    // Input'ları temizle
    if (zenTitleInput) {
      zenTitleInput.value = '';
    }
    if (zenBodyInput) {
      zenBodyInput.value = '';
    }
    if (zenHighlight) {
      zenHighlight.innerHTML = '';
    }
    
  }
}

function saveZenNote() {
  const zenTitleInput = document.getElementById('zenTitleInput');
  const zenBodyInput = document.getElementById('zenBodyInput');
  
  if (!zenTitleInput || !zenBodyInput) {
    console.error('Zen Mode input elementleri bulunamadı!');
    return;
  }
  
  const title = zenTitleInput.value.trim() || 'Başlıksız Not';
  const text = zenBodyInput.value.trim();
  
  if (text === '' && title === 'Başlıksız Not') {
    closeZenMode();
    return;
  }
  
  if (zenCurrentNoteId) {
    // Mevcut notu güncelle
    updateNote(zenCurrentNoteId, title, text);
  } else {
    // Yeni not oluştur
    const note = {
      id: generateId(),
      title: title,
      text: text,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      tags: extractTags(text),
      links: extractLinks(text),
      folderId: null
    };
    
    notes.unshift(note);
    saveNotes();
    renderNotes();
    renderTags();
    renderFolderList();
    selectNote(note.id);
  }
  
  closeZenMode();
}

function updateZenStats() {
  const zenBodyInput = document.getElementById('zenBodyInput');
  const zenWordCount = document.getElementById('zenWordCount');
  const zenCharCount = document.getElementById('zenCharCount');
  const zenLineCount = document.getElementById('zenLineCount');
  
  if (!zenBodyInput || !zenWordCount || !zenCharCount || !zenLineCount) return;
  
  const text = zenBodyInput.value;
  const words = text.trim() === '' ? 0 : text.trim().split(/\s+/).length;
  const chars = text.length;
  const lines = text.split('\n').length;
  
  zenWordCount.textContent = words + ' kelime';
  zenCharCount.textContent = chars + ' karakter';
  zenLineCount.textContent = lines + ' satır';
}

function updateZenHighlight() {
  const zenBodyInput = document.getElementById('zenBodyInput');
  const zenHighlight = document.getElementById('zenHighlight');
  
  if (!zenBodyInput || !zenHighlight) return;
  
  const text = zenBodyInput.value;
  
  if (text.trim() === '') {
    zenHighlight.innerHTML = '';
    return;
  }
  
  // Metni satır satır işle
  const lines = text.split('\n');
  let highlightedHTML = '';
  
  lines.forEach((line, index) => {
    let processedLine = line;
    
    // Boş satır
    if (line.trim() === '') {
      highlightedHTML += '\n';
      return;
    }
    
    // Checkbox'lar: - [ ] veya - [x]
    processedLine = processedLine.replace(/^(\s*)-\s*\[\s*\]\s*(.*)$/, '$1<span class="checkbox">☐</span> $2');
    processedLine = processedLine.replace(/^(\s*)-\s*\[x\]\s*(.*)$/, '$1<span class="checkbox checked">☑</span> $2');
    
    // Başlıklar: #, ##, ###
    processedLine = processedLine.replace(/^(\s*)(#{1,3})\s+(.*)$/, (match, spaces, hashes, content) => {
      const level = hashes.length;
      return `${spaces}<span class="header h${level}">${hashes} ${content}</span>`;
    });
    
    // Alıntılar: >
    processedLine = processedLine.replace(/^(\s*)>\s*(.*)$/, '$1<span class="quote">> $2</span>');
    
    // Etiketler: #etiket (başlık değilse ve 1+ karakter, Türkçe destekli)
    if (!processedLine.includes('<span class="header')) {
      processedLine = processedLine.replace(/#([a-zA-ZçÇğĞıİöÖşŞüÜ0-9_]+)/g, '<span class="tag">#$1</span>');
    }
    
    // Wikilinks: [[link]] (1+ karakter)
    processedLine = processedLine.replace(/\[\[([^\]]+)\]\]/g, '<span class="wikilink">[[$1]]</span>');
    
    // Kod: `kod` (1+ karakter)
    processedLine = processedLine.replace(/`([^`]{1,})`/g, '<span class="code">`$1`</span>');
    
    highlightedHTML += processedLine;
    if (index < lines.length - 1) {
      highlightedHTML += '\n';
    }
  });
  
  zenHighlight.innerHTML = highlightedHTML;
}


function autoResizeZenTitle() {
  const zenTitleInput = document.getElementById('zenTitleInput');
  if (!zenTitleInput) return;
  
  zenTitleInput.style.height = 'auto';
  zenTitleInput.style.height = Math.max(40, zenTitleInput.scrollHeight) + 'px';
}

// Wikilink Autocomplete Fonksiyonları
function showWikilinkAutocomplete(textarea, searchText, cursorPos) {
  hideWikilinkAutocomplete();
  
  if (!searchText || searchText.length < 1) return;
  
  // Not başlıklarında arama yap
  const matches = notes.filter(note => 
    note.title.toLowerCase().includes(searchText.toLowerCase()) &&
    note.id !== zenCurrentNoteId // Kendi notunu hariç tut
  ).slice(0, 8); // Max 8 sonuç
  
  if (matches.length === 0) return;
  
  // Autocomplete div'i oluştur
  wikilinkAutocomplete = document.createElement('div');
  wikilinkAutocomplete.className = 'wikilink-autocomplete';
  
  // Pozisyon hesapla
  const textareaRect = textarea.getBoundingClientRect();
  const textBeforeCursor = textarea.value.substring(0, cursorPos);
  const lines = textBeforeCursor.split('\n');
  const currentLineIndex = lines.length - 1;
  const currentLineText = lines[currentLineIndex];
  
  // Kabaca pozisyon hesapla
  const lineHeight = 20;
  const charWidth = 8;
  const top = textareaRect.top + (currentLineIndex * lineHeight) + lineHeight + 5;
  const left = textareaRect.left + (currentLineText.length * charWidth);
  
  wikilinkAutocomplete.style.top = Math.min(top, window.innerHeight - 220) + 'px';
  wikilinkAutocomplete.style.left = Math.min(left, window.innerWidth - 220) + 'px';
  
  // Sonuçları ekle
  matches.forEach((note, index) => {
    const item = document.createElement('div');
    item.className = 'wikilink-autocomplete-item';
    if (index === 0) item.classList.add('selected');
    
    const snippet = note.text.length > 50 ? note.text.substring(0, 50) + '...' : note.text;
    
    item.innerHTML = `
      <div class="wikilink-autocomplete-title">${escapeHtml(note.title)}</div>
      <div class="wikilink-autocomplete-snippet">${escapeHtml(snippet)}</div>
    `;
    
    item.onclick = () => selectWikilinkSuggestion(textarea, note.title, cursorPos, searchText);
    wikilinkAutocomplete.appendChild(item);
  });
  
  selectedAutocompleteIndex = 0;
  document.body.appendChild(wikilinkAutocomplete);
}

function hideWikilinkAutocomplete() {
  if (wikilinkAutocomplete) {
    wikilinkAutocomplete.remove();
    wikilinkAutocomplete = null;
    selectedAutocompleteIndex = -1;
  }
}

function selectWikilinkSuggestion(textarea, title, cursorPos, searchText) {
  const textBeforeCursor = textarea.value.substring(0, cursorPos);
  const textAfterCursor = textarea.value.substring(cursorPos);
  
  // [[ ile başlayan kısmı bul
  const wikiStartIndex = textBeforeCursor.lastIndexOf('[[');
  const beforeWiki = textBeforeCursor.substring(0, wikiStartIndex);
  
  // Yeni metni oluştur
  const newText = beforeWiki + `[[${title}]]` + textAfterCursor;
  textarea.value = newText;
  
  // Cursor'u ]] sonrasına yerleştir
  const newCursorPos = beforeWiki.length + title.length + 4;
  textarea.selectionStart = textarea.selectionEnd = newCursorPos;
  
  hideWikilinkAutocomplete();
  updateZenStats();
  updateZenHighlight();
}

function navigateWikilinkAutocomplete(direction) {
  if (!wikilinkAutocomplete) return false;
  
  const items = wikilinkAutocomplete.querySelectorAll('.wikilink-autocomplete-item');
  if (items.length === 0) return false;
  
  // Mevcut seçimi kaldır
  items[selectedAutocompleteIndex]?.classList.remove('selected');
  
  // Yeni index hesapla
  if (direction === 'down') {
    selectedAutocompleteIndex = (selectedAutocompleteIndex + 1) % items.length;
  } else if (direction === 'up') {
    selectedAutocompleteIndex = selectedAutocompleteIndex <= 0 ? items.length - 1 : selectedAutocompleteIndex - 1;
  }
  
  // Yeni seçimi uygula
  items[selectedAutocompleteIndex].classList.add('selected');
  items[selectedAutocompleteIndex].scrollIntoView({ block: 'nearest' });
  
  return true;
}

function selectCurrentWikilinkSuggestion(textarea, cursorPos, searchText) {
  if (!wikilinkAutocomplete || selectedAutocompleteIndex === -1) return false;
  
  const items = wikilinkAutocomplete.querySelectorAll('.wikilink-autocomplete-item');
  const selectedItem = items[selectedAutocompleteIndex];
  if (!selectedItem) return false;
  
  const title = selectedItem.querySelector('.wikilink-autocomplete-title').textContent;
  selectWikilinkSuggestion(textarea, title, cursorPos, searchText);
  return true;
}



// Electron entegrasyonu
let ipcRenderer;
try {
  ipcRenderer = require('electron').ipcRenderer;
  
  // Window show/hide eventlerini dinle
  ipcRenderer.on('main-window-shown', () => {
    openWidget();
  });
  
  ipcRenderer.on('main-window-hidden', () => {
    closeWidget();
  });
  
} catch (e) {
  // Web tarayıcısında çalışıyorsa mock ipcRenderer
  ipcRenderer = {
    send: (channel, data) => {
      if (channel === 'toggle-main-window') {
        // Mock ortamda toggle
        const widget = document.getElementById('widget');
        if (widget.classList.contains('open')) {
        closeWidget();
        } else {
          openWidget();
        }
      }
    }
  };
}

// Electron için özel ayarlar
if (typeof require !== 'undefined') {
  // Electron ortamında çalışıyor
  const { webFrame } = require('electron');
  // Zoom seviyesini sıfırla
  webFrame.setZoomLevel(0);
  // DevTools'u kapat
  webFrame.setVisualZoomLevelLimits(1, 1);
  
  // Memory optimization
  webFrame.clearCache();
  
  // GPU ayarları
  if (process.platform === 'win32') {
    // Windows'ta GPU bellek optimizasyonu
    document.body.style.transform = 'translateZ(0)';
  }
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
  // Buton eventleri
  const closeBtn = document.getElementById('closeBtn');
  const newBtn = document.getElementById('newBtn');
  const saveBtn = document.getElementById('saveBtn');
  const delBtn = document.getElementById('delBtn');
  const closeDrawerBtn = document.getElementById('closeDrawerBtn');
  const searchInput = document.getElementById('q');
  const titleInput = document.getElementById('titleIn');
  const bodyInput = document.getElementById('bodyIn');
  
  // Zoom kontrolleri
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetZoomBtn = document.getElementById('resetZoomBtn');
  const boardwrap = document.querySelector('.boardwrap');
  
  
  if (closeBtn) closeBtn.onclick = () => {
    ipcRenderer.send('toggle-main-window');
  };
  
  if (newBtn) newBtn.onclick = () => {
    createNote();
  };
  
  // Sidebar toggle button
  const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
  if (toggleSidebarBtn) toggleSidebarBtn.onclick = toggleSidebar;
  
  if (saveBtn) saveBtn.onclick = () => {
    if (selectedNote) {
      updateNote(selectedNote, 
        titleInput ? titleInput.value : '',
        bodyInput ? bodyInput.value : ''
      );
    }
  };
  
  if (delBtn) delBtn.onclick = () => {
    if (selectedNote) {
      deleteNote(selectedNote);
    }
  };
  
  if (closeDrawerBtn) closeDrawerBtn.onclick = () => {
    closeDrawer();
  };
  
  // Zoom butonları
  if (zoomInBtn) zoomInBtn.onclick = zoomIn;
  if (zoomOutBtn) zoomOutBtn.onclick = zoomOut;
  if (resetZoomBtn) resetZoomBtn.onclick = fitAllNotes;
  
  
  // Zen Mode event listeners
  const zenCancelBtn = document.getElementById('zenCancelBtn');
  const zenSaveBtn = document.getElementById('zenSaveBtn');
  const zenTitleInput = document.getElementById('zenTitleInput');
  const zenBodyInput = document.getElementById('zenBodyInput');
  const zenOverlay = document.getElementById('zenOverlay');
  
  if (zenCancelBtn) zenCancelBtn.onclick = closeZenMode;
  if (zenSaveBtn) zenSaveBtn.onclick = saveZenNote;
  
  // Zen Mode keyboard shortcuts - Document level
  document.addEventListener('keydown', (e) => {
    const zenOverlay = document.getElementById('zenOverlay');
    const deleteModalOverlay = document.getElementById('deleteModalOverlay');
    
    // Delete modal açıksa ESC ile kapat
    if (deleteModalOverlay && deleteModalOverlay.classList.contains('active')) {
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        closeDeleteModal();
        return;
      }
    }
    
    if (zenOverlay && zenOverlay.classList.contains('active')) {
      // ESC - Sadece Zen Mode'u kapat, widget'ı kapama
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        hideWikilinkAutocomplete(); // Autocomplete'i de kapat
        closeZenMode();
        return;
      }
      // Ctrl+S - Kaydet
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        e.stopPropagation();
        saveZenNote();
        return;
      }
    }
  });
  
  // Wikilink autocomplete'i kapatmak için click eventi
  document.addEventListener('click', (e) => {
    if (wikilinkAutocomplete && !wikilinkAutocomplete.contains(e.target)) {
      hideWikilinkAutocomplete();
    }
  });
  
  // Zen Title Input events
  if (zenTitleInput) {
    zenTitleInput.addEventListener('input', () => {
      autoResizeZenTitle();
      updateZenStats();
    });
    
    zenTitleInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        zenBodyInput?.focus();
      }
    });
  }
  
  // Zen Body Input events
  if (zenBodyInput) {
    zenBodyInput.addEventListener('input', (e) => {
      const cursorPos = e.target.selectionStart;
      const textBeforeCursor = e.target.value.substring(0, cursorPos);
      
      // Wikilink autocomplete kontrolü
      const wikiStartIndex = textBeforeCursor.lastIndexOf('[[');
      const wikiEndIndex = textBeforeCursor.lastIndexOf(']]');
      
      // [[ yazdıktan sonra ve ]] yazmadan önce autocomplete göster
      if (wikiStartIndex !== -1 && (wikiEndIndex === -1 || wikiStartIndex > wikiEndIndex)) {
        const searchText = textBeforeCursor.substring(wikiStartIndex + 2);
        showWikilinkAutocomplete(e.target, searchText, cursorPos);
      } else {
        hideWikilinkAutocomplete();
      }
      
      // Markdown kısayolları
      const lines = textBeforeCursor.split('\n');
      const currentLine = lines[lines.length - 1];
      const spaces = currentLine.match(/^(\s*)/)[1];
      
      // Checkbox kısayolları: -- → - [ ] , -x → - [x] 
      if (currentLine.match(/^(\s*)--$/)) {
        const beforeLine = textBeforeCursor.substring(0, textBeforeCursor.lastIndexOf('\n') + 1);
        const afterCursor = e.target.value.substring(cursorPos);
        
        e.target.value = beforeLine + spaces + '- [ ] ' + afterCursor;
        e.target.selectionStart = e.target.selectionEnd = beforeLine.length + spaces.length + 6;
      }
      // Checked checkbox: -x → - [x] 
      else if (currentLine.match(/^(\s*)-x$/)) {
        const beforeLine = textBeforeCursor.substring(0, textBeforeCursor.lastIndexOf('\n') + 1);
        const afterCursor = e.target.value.substring(cursorPos);
        
        e.target.value = beforeLine + spaces + '- [x] ' + afterCursor;
        e.target.selectionStart = e.target.selectionEnd = beforeLine.length + spaces.length + 6;
      }
      
      updateZenStats();
      updateZenHighlight();
    });
    
    zenBodyInput.addEventListener('keydown', (e) => {
      // Wikilink autocomplete keyboard navigation
      if (wikilinkAutocomplete) {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          navigateWikilinkAutocomplete('down');
          return;
        }
        if (e.key === 'ArrowUp') {
          e.preventDefault();
          navigateWikilinkAutocomplete('up');
          return;
        }
        if (e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          const cursorPos = e.target.selectionStart;
          const textBeforeCursor = e.target.value.substring(0, cursorPos);
          const searchText = textBeforeCursor.substring(textBeforeCursor.lastIndexOf('[[') + 2);
          selectCurrentWikilinkSuggestion(e.target, cursorPos, searchText);
          return;
        }
        if (e.key === 'Escape') {
          e.preventDefault();
          hideWikilinkAutocomplete();
          return;
        }
      }
      
      // Tab desteği
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = e.target.selectionStart;
        const end = e.target.selectionEnd;
        e.target.value = e.target.value.substring(0, start) + '  ' + e.target.value.substring(end);
        e.target.selectionStart = e.target.selectionEnd = start + 2;
        updateZenStats();
        updateZenHighlight();
      }
    });
    
    // Scroll sync - textarea ve highlight aynı scroll olsun
    zenBodyInput.addEventListener('scroll', () => {
      const zenHighlight = document.getElementById('zenHighlight');
      if (zenHighlight) {
        zenHighlight.scrollTop = zenBodyInput.scrollTop;
        zenHighlight.scrollLeft = zenBodyInput.scrollLeft;
      }
    });
  }
  
  // Board wheel eventi (zoom)
  if (boardwrap) {
    boardwrap.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (e.ctrlKey) {
        // Ctrl + tekerlek = zoom
        if (e.deltaY < 0) {
          zoomIn();
        } else {
          zoomOut();
        }
      } else {
        // Tekerlek = pan (yukarı/aşağı)
        boardPanY -= e.deltaY;
        updateBoardTransform();
      }
    });
    
    // Mouse events (orta tuş pan + sol tık selection)
    boardwrap.addEventListener('mousedown', (e) => {
      if (e.button === 1) { // Orta tuş - pan
        e.preventDefault();
        isMiddleMouseDown = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        lastPanX = boardPanX;
        lastPanY = boardPanY;
        boardwrap.style.cursor = 'grabbing';
      } else if (e.button === 0) { // Sol tık - selection
        // Eğer nota tıklanmadıysa selection başlat
        if (e.target === boardwrap || e.target.id === 'board') {
          // Önce tüm seçimleri temizle (single ve multi)
          clearAllSelections();
          startSelection(e);
        }
      }
    });
    
    boardwrap.addEventListener('mousemove', (e) => {
      if (isMiddleMouseDown) {
        e.preventDefault();
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        
        boardPanX = lastPanX + deltaX;
        boardPanY = lastPanY + deltaY;
        
        updateBoardTransform();
      }
    });
    
    boardwrap.addEventListener('mouseup', (e) => {
      if (e.button === 1) {
        isMiddleMouseDown = false;
        boardwrap.style.cursor = 'default';
      }
    });
    
    // Mouse board'dan çıkınca pan'i durdur
    boardwrap.addEventListener('mouseleave', () => {
      isMiddleMouseDown = false;
      boardwrap.style.cursor = 'default';
    });
    
    // Orta tuş context menu'sünü engelle
    boardwrap.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });
  }
  
  // Arama
  if (searchInput) {
    searchInput.oninput = (e) => {
      searchQuery = e.target.value;
      renderNotes();
      renderNoteList();
    };
    console.log('Arama input listener eklendi');
  }
  
  // Editör
  if (titleInput) {
    titleInput.oninput = () => {
      console.log('Başlık değişti:', titleInput.value);
      renderPreview();
    };
    console.log('Başlık input listener eklendi');
  }
  
  if (bodyInput) {
    bodyInput.oninput = () => {
      console.log('İçerik değişti:', bodyInput.value.substring(0, 50) + '...');
      renderPreview();
    };
    console.log('İçerik input listener eklendi');
  }
  
  // Kısayollar
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey) {
      switch(e.key) {
        case 'n':
          e.preventDefault();
          createNote();
          break;
        case 'f':
          e.preventDefault();
          if (searchInput) searchInput.focus();
          break;
        case 'Enter':
          e.preventDefault();
          if (saveBtn) saveBtn.click();
          break;
      }
    }
    // ESC artık sadece Zen Mode'u kapatır, widget'a dokunmaz
  });
  
  // Tab işlevselliği
  const tabs = document.querySelectorAll('.tab');
  const tabContents = document.querySelectorAll('.tab-content');
  
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const targetTab = tab.dataset.tab;
      
      // Tüm tab'ları deaktive et
      tabs.forEach(t => t.classList.remove('active'));
      tabContents.forEach(tc => tc.classList.remove('active'));
      
      // Seçilen tab'ı aktive et
      tab.classList.add('active');
      document.getElementById(`tab-${targetTab}`).classList.add('active');
      
      console.log(`Tab değişti: ${targetTab}`);
    });
  });
  
  // Başlangıç
  loadNotes();
  loadFolders();
  renderNotes();
  renderTags();
  renderFolderList();
  renderGraph();
  openWidget(); // Widget başlangıçta açık olsun
  
  // Sol sidebar butonları - Debug ile
  const newNoteBtn = document.getElementById('newNoteBtn');
  const newFolderBtn = document.getElementById('newFolderBtn');
  
  // Etiket arama elemanları
  const tagSearchInput = document.getElementById('tagSearch');
  const clearSearchBtn = document.getElementById('clearSearch');
  
  console.log('Butonlar bulundu:', {
    newNoteBtn: !!newNoteBtn,
    newFolderBtn: !!newFolderBtn,
    tagSearchInput: !!tagSearchInput,
    clearSearchBtn: !!clearSearchBtn
  });
  
  if (newNoteBtn) {
    newNoteBtn.onclick = () => {
      createNote();
    };
  } else {
    console.error('newNoteBtn elementi bulunamadı!');
  }
  
  if (newFolderBtn) {
    newFolderBtn.onclick = () => {
      createFolder();
    };
  } else {
    console.error('newFolderBtn elementi bulunamadı!');
  }
  
  // Etiket arama
  if (tagSearchInput) {
    tagSearchInput.oninput = (e) => {
      searchTags(e.target.value);
    };
  } else {
    console.error('tagSearchInput elementi bulunamadı!');
  }
  
  // Arama temizle
  if (clearSearchBtn) {
    clearSearchBtn.onclick = () => {
      clearTagSearch();
    };
  } else {
    console.error('clearSearchBtn elementi bulunamadı!');
  }
  
  // Multi-selection fonksiyonları
  function startSelection(e) {
    // Mevcut seçimleri temizle
    clearSelection();
    
    const boardwrap = document.querySelector('.boardwrap');
    const boardwrapRect = boardwrap.getBoundingClientRect();
    
    // Pan ve zoom'u hesaba katarak koordinat hesapla
    const rawX = e.clientX - boardwrapRect.left;
    const rawY = e.clientY - boardwrapRect.top;
    
    // Zoom ve pan'i tersine çevir
    selectionStartX = (rawX - boardPanX) / boardZoom;
    selectionStartY = (rawY - boardPanY) / boardZoom;
    isSelecting = true;
    
    // Selection box oluştur
    const board = document.getElementById('board');
    selectionBox = document.createElement('div');
    selectionBox.className = 'selection-box';
    selectionBox.style.left = selectionStartX + 'px';
    selectionBox.style.top = selectionStartY + 'px';
    selectionBox.style.width = '0px';
    selectionBox.style.height = '0px';
    board.appendChild(selectionBox);
    
    e.preventDefault();
  }
  
  function updateSelection(e) {
    if (!isSelecting || !selectionBox) return;
    
    const boardwrap = document.querySelector('.boardwrap');
    const boardwrapRect = boardwrap.getBoundingClientRect();
    
    // Pan ve zoom'u hesaba katarak current koordinat hesapla
    const rawX = e.clientX - boardwrapRect.left;
    const rawY = e.clientY - boardwrapRect.top;
    
    // Zoom ve pan'i tersine çevir
    const currentX = (rawX - boardPanX) / boardZoom;
    const currentY = (rawY - boardPanY) / boardZoom;
    
    const left = Math.min(selectionStartX, currentX);
    const top = Math.min(selectionStartY, currentY);
    const width = Math.abs(currentX - selectionStartX);
    const height = Math.abs(currentY - selectionStartY);
    
    selectionBox.style.left = left + 'px';
    selectionBox.style.top = top + 'px';
    selectionBox.style.width = width + 'px';
    selectionBox.style.height = height + 'px';
    
    // Notları kontrol et
    checkNotesInSelection(left, top, width, height);
  }
  
  function checkNotesInSelection(selLeft, selTop, selWidth, selHeight) {
    const noteElements = document.querySelectorAll('.note');
    const newSelectedNotes = [];
    
    noteElements.forEach(noteElement => {
      // Not pozisyonlarını doğrudan style'dan oku (board koordinat sisteminde)
      const noteLeft = parseFloat(noteElement.style.left) || 0;
      const noteTop = parseFloat(noteElement.style.top) || 0;
      const noteWidth = parseFloat(noteElement.style.width) || 280;
      const noteHeight = parseFloat(noteElement.style.height) || 160;
      
      // Intersection kontrolü
      if (noteLeft < selLeft + selWidth &&
          noteLeft + noteWidth > selLeft &&
          noteTop < selTop + selHeight &&
          noteTop + noteHeight > selTop) {
        
        const noteId = noteElement.id.replace('note-', '');
        newSelectedNotes.push(noteId);
        noteElement.classList.add('multi-selected');
      } else {
        noteElement.classList.remove('multi-selected');
      }
    });
    
    selectedNotes = newSelectedNotes;
  }
  
  function endSelection() {
    if (!isSelecting) return;
    
    isSelecting = false;
    
    if (selectionBox) {
      selectionBox.remove();
      selectionBox = null;
    }
  }
  
  function clearSelection() {
    selectedNotes = [];
    const noteElements = document.querySelectorAll('.note.multi-selected');
    noteElements.forEach(element => {
      element.classList.remove('multi-selected');
    });
    
    if (selectionBox) {
      selectionBox.remove();
      selectionBox = null;
    }
    isSelecting = false;
  }
  
  function clearAllSelections() {
    // Multi-selection temizle
    clearSelection();
    
    // Single selection temizle
    selectedNote = null;
    selectedFolder = null;
    
    // Tüm seçim CSS sınıflarını kaldır
    document.querySelectorAll('.note.selected').forEach(element => {
      element.classList.remove('selected');
    });
    
    document.querySelectorAll('.folder-card.selected').forEach(element => {
      element.classList.remove('selected');
    });
    
    // UI'ları güncelle
    renderGraph(); // Minimap'i güncelle
    renderFolderList(); // Sidebar'ı güncelle
  }
  
  // Global mouse eventleri
  document.addEventListener('mousedown', (e) => {
    // Sağ tık ise drag tracking yapma (context menu için)
    if (e.button === 2) return;
    
    // Not ve klasör kartlarına mousedown handling (sadece sol tık)
    if (e.target.closest('.note') || e.target.closest('.folder-card')) {
      const element = e.target.closest('.note') || e.target.closest('.folder-card');
      
      // Drag başlangıç verilerini kaydet
      element.dataset.clickStartX = e.clientX;
      element.dataset.clickStartY = e.clientY;
      element.dataset.mouseDownTime = Date.now();
      
      // Initial pozisyonları da kaydet
      if (element.classList.contains('note')) {
        const noteId = element.id.replace('note-', '');
        const note = notes.find(n => n.id === noteId);
        if (note) {
          element.dataset.dragStartX = e.clientX - document.getElementById('board').getBoundingClientRect().left;
          element.dataset.dragStartY = e.clientY - document.getElementById('board').getBoundingClientRect().top;
          element.dataset.initialNoteX = note.x;
          element.dataset.initialNoteY = note.y;
        }
      } else if (element.classList.contains('folder-card')) {
        const folderId = element.id.replace('folder-', '');
        const folder = folders.find(f => f.id === folderId);
        if (folder) {
          element.dataset.dragStartX = e.clientX - document.getElementById('board').getBoundingClientRect().left;
          element.dataset.dragStartY = e.clientY - document.getElementById('board').getBoundingClientRect().top;
          element.dataset.initialFolderX = folder.x;
          element.dataset.initialFolderY = folder.y;
        }
      }
    }
  });
  
  document.addEventListener('mousemove', (e) => {
    // Selection box güncelle
    if (isSelecting) {
      updateSelection(e);
    }
    
    // Önce mousedown'dan itibaren hareket kontrolü (notlar ve klasörler)
    const allNotes = document.querySelectorAll('.note');
    const allFolders = document.querySelectorAll('.folder-card');
    
    allNotes.forEach(element => {
      if (element.dataset.clickStartX && element.dataset.clickStartY) {
        const startX = parseFloat(element.dataset.clickStartX);
        const startY = parseFloat(element.dataset.clickStartY);
        const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
        
        // 5px hareket threshold'u
        if (distance > 5 && !element.classList.contains('dragging')) {
          element.classList.add('dragging');
          element.style.cursor = 'grabbing';
        }
      }
    });
    
    allFolders.forEach(element => {
      if (element.dataset.clickStartX && element.dataset.clickStartY) {
        const startX = parseFloat(element.dataset.clickStartX);
        const startY = parseFloat(element.dataset.clickStartY);
        const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
        
        // 5px hareket threshold'u
        if (distance > 5 && !element.classList.contains('dragging')) {
          element.classList.add('dragging');
          element.style.cursor = 'grabbing';
        }
      }
    });

    // Tüm dragging kartları için drag fonksiyonunu çağır (notlar ve klasörler)
    const draggingNotes = document.querySelectorAll('.note.dragging');
    const draggingFolders = document.querySelectorAll('.folder-card.dragging');
    
    // Not kartlarını sürükle
    draggingNotes.forEach(element => {
      const noteId = element.id.replace('note-', '');
      const note = notes.find(n => n.id === noteId);
      if (note) {
        // Mouse koordinatlarını canvas koordinatlarına çevir
        const board = document.getElementById('board');
        const boardRect = board.getBoundingClientRect();
        
        const currentX = e.clientX - boardRect.left;
        const currentY = e.clientY - boardRect.top;
        
        // Başlangıç pozisyonlarını hesapla (drag başlangıcında kaydedilmiş olmalı)
        const startX = parseFloat(element.dataset.dragStartX || 0);
        const startY = parseFloat(element.dataset.dragStartY || 0);
        const initialNoteX = parseFloat(element.dataset.initialNoteX || 0);
        const initialNoteY = parseFloat(element.dataset.initialNoteY || 0);
        
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Eğer bu not multi-selection'ın parçasıysa, tüm seçili notları birlikte taşı
        if (selectedNotes.includes(noteId)) {
          // Tüm seçili notları delta ile birlikte hareket ettir
          selectedNotes.forEach(selectedId => {
            const selectedNote = notes.find(n => n.id === selectedId);
            const selectedElement = document.getElementById(`note-${selectedId}`);
            if (selectedNote && selectedElement && selectedElement.dataset.initialNoteX !== undefined) {
              const selectedInitialX = parseFloat(selectedElement.dataset.initialNoteX || 0);
              const selectedInitialY = parseFloat(selectedElement.dataset.initialNoteY || 0);
              
              // Pozisyonu güncelle
              selectedNote.x = selectedInitialX + deltaX / boardZoom;
              selectedNote.y = selectedInitialY + deltaY / boardZoom;
              
              // Element pozisyonunu güncelle
              selectedElement.style.left = selectedNote.x + 'px';
              selectedElement.style.top = selectedNote.y + 'px';
              selectedElement.style.transform = 'none';
            }
          });
        } else {
          // Tek not için normal drag
          note.x = initialNoteX + deltaX / boardZoom;
          note.y = initialNoteY + deltaY / boardZoom;
          
          // Element pozisyonunu güncelle
          element.style.left = note.x + 'px';
          element.style.top = note.y + 'px';
          element.style.transform = 'none';
        }
      }
    });
    
    // Klasör kartlarını sürükle
    draggingFolders.forEach(element => {
      const folderId = element.id.replace('folder-', '');
      const folder = folders.find(f => f.id === folderId);
      if (folder) {
        // Mouse koordinatlarını canvas koordinatlarına çevir
        const board = document.getElementById('board');
        const boardRect = board.getBoundingClientRect();
        
        const currentX = e.clientX - boardRect.left;
        const currentY = e.clientY - boardRect.top;
        
        // Başlangıç pozisyonlarını hesapla
        const startX = parseFloat(element.dataset.dragStartX || 0);
        const startY = parseFloat(element.dataset.dragStartY || 0);
        const initialFolderX = parseFloat(element.dataset.initialFolderX || 0);
        const initialFolderY = parseFloat(element.dataset.initialFolderY || 0);
        
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Klasör pozisyonunu güncelle (zoom'a göre)
        folder.x = initialFolderX + deltaX / boardZoom;
        folder.y = initialFolderY + deltaY / boardZoom;
        
        // Element pozisyonunu güncelle
        element.style.left = folder.x + 'px';
        element.style.top = folder.y + 'px';
        element.style.transform = 'none';
      }
    });
    
    // Bağlantıları güncelle
    if (draggingNotes.length > 0 || draggingFolders.length > 0) {
      drawFolderConnections();
      drawConnections();
      renderGraph();
    }
  });
  
  document.addEventListener('mouseup', (e) => {
    // Sağ tık ise click handling yapma
    if (e.button === 2) return;
    
    // Selection box bitir
    if (isSelecting) {
      endSelection();
    }
    
    // Tüm notları ve klasörleri kontrol et
    const allNotes = document.querySelectorAll('.note');
    const allFolders = document.querySelectorAll('.folder-card');
    
    allNotes.forEach(element => {
      if (element.dataset.clickStartX && element.dataset.clickStartY) {
        const startX = parseFloat(element.dataset.clickStartX);
        const startY = parseFloat(element.dataset.clickStartY);
        const mouseDownTime = parseFloat(element.dataset.mouseDownTime);
        const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
        const timeDiff = Date.now() - mouseDownTime;
        
        // Click detection (hareket az ve süre kısa)
        if (distance < 5 && timeDiff < 500 && !element.classList.contains('dragging')) {
          // Eğer checkbox veya mini buton'a tıklanmadıysa
          if (!e.target.classList.contains('checklist-checkbox') && !e.target.classList.contains('mini')) {
            const noteId = element.id.replace('note-', '');
            // Seçimleri temizle ve notu aç
            clearAllSelections();
            openNoteDetail(noteId);
          }
        }
        
        // Dataset'i temizle
        delete element.dataset.clickStartX;
        delete element.dataset.clickStartY;
        delete element.dataset.mouseDownTime;
      }
    });
    
    // Klasör kartları için click handling
    allFolders.forEach(element => {
      if (element.dataset.clickStartX && element.dataset.clickStartY) {
        const startX = parseFloat(element.dataset.clickStartX);
        const startY = parseFloat(element.dataset.clickStartY);
        const mouseDownTime = parseFloat(element.dataset.mouseDownTime);
        const distance = Math.sqrt(Math.pow(e.clientX - startX, 2) + Math.pow(e.clientY - startY, 2));
        const timeDiff = Date.now() - mouseDownTime;
        
        // Click detection (hareket az ve süre kısa)
        if (distance < 5 && timeDiff < 500 && !element.classList.contains('dragging')) {
          const folderId = element.id.replace('folder-', '');
          selectFolder(folderId);
        }
        
        // Dataset'i temizle
        delete element.dataset.clickStartX;
        delete element.dataset.clickStartY;
        delete element.dataset.mouseDownTime;
      }
    });

    const draggingNotes = document.querySelectorAll('.note.dragging');
    const draggingFolders = document.querySelectorAll('.folder-card.dragging');
    
    // Not kartlarını temizle
    draggingNotes.forEach(element => {
      element.classList.remove('dragging');
      element.style.cursor = 'grab';
      
      // Pozisyonu kaydet
      const noteId = element.id.replace('note-', '');
      saveNotes();
    });
    
    // Klasör kartlarını temizle
    draggingFolders.forEach(element => {
      element.classList.remove('dragging');
      element.style.cursor = 'grab';
      
      // Pozisyonu kaydet
      const folderId = element.id.replace('folder-', '');
      saveFolders();
    });
    
    // Bağlantıları güncelle
    if (draggingNotes.length > 0 || draggingFolders.length > 0) {
      drawFolderConnections();
      drawConnections();
      renderGraph();
    }
  });
  
  // Resize event'i
  window.addEventListener('resize', () => {
    drawFolderConnections();
    drawConnections();
    renderGraph();
  });
  
});
</script>
</body>
</html>